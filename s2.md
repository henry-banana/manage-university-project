Okay, I will continue with the implementation, focusing on the SQL data access layer, related parsers, updating the DaoFactory, implementing validators, the AuthService with mock DAOs, and the UI helper classes. Due to the response size limit, I'll prioritize getting representative examples working and then expand if possible.

--- START OF FILE IEntityParser.h ---
```cpp
#ifndef IENTITYPARSER_H
#define IENTITYPARSER_H

#include <expected>
#include <vector>
#include <string>
#include <any> // For DbQueryResultRow if TRow is map<string, any>
#include "../../../common/ErrorType.h"

// TRow: Kiểu dữ liệu của một hàng thô (ví dụ: std::vector<std::string> cho CSV, DbQueryResultRow cho SQL)
template <typename TEntity, typename TRow>
class IEntityParser {
public:
    virtual ~IEntityParser() = default;

    // Chuyển một hàng thô thành một đối tượng Entity
    virtual std::expected<TEntity, Error> parse(const TRow& rowData) const = 0;

    // Chuyển một đối tượng Entity thành một hàng thô (dùng để ghi)
    // TRow có thể cần là con trỏ hoặc tham chiếu tùy vào cách TRow được định nghĩa (ví dụ nếu TRow là vector string thì trả về vector string)
    // Đối với SQL, có thể sẽ cần nhiều hơn một hàm serialize (ví dụ serializeForInsert, serializeForUpdate)
    // hoặc TRow có thể là một struct chứa các tham số cho câu lệnh SQL.
    // Hiện tại, để đơn giản, giả sử TRow là kiểu dữ liệu dùng để ghi (vd: vector string cho CSV)
    virtual TRow serialize(const TEntity& entity) const = 0;
};

#endif // IENTITYPARSER_H
```
--- END OF FILE IEntityParser.h ---

--- START OF FILE SqlStudentParser.h ---
```cpp
#ifndef SQLSTUDENTPARSER_H
#define SQLSTUDENTPARSER_H

#include "../interface/IEntityParser.h"
#include "../../../../core/entities/Student.h"
#include "../../../../core/data_access/database_adapter/interface/IDatabaseAdapter.h" // For DbQueryResultRow
#include "../../../../common/LoginStatus.h"
#include "../../../../common/UserRole.h"
#include <string>
#include <vector>

// Helper function to safely get value from std::any
template<typename T>
T safe_any_cast(const std::any& a, const std::string& fieldName, ValidationResult& vr, T defaultValue = T{}) {
    if (!a.has_value()) {
        // vr.addError(ErrorCode::PARSING_ERROR, "Field '" + fieldName + "' is missing or null."); // Có thể không phải lỗi, tùy DB
        return defaultValue;
    }
    try {
        return std::any_cast<T>(a);
    } catch (const std::bad_any_cast& e) {
        vr.addError(ErrorCode::PARSING_ERROR, "Field '" + fieldName + "' has incorrect type: " + e.what());
        return defaultValue;
    }
}

class SqlStudentParser : public IEntityParser<Student, DbQueryResultRow> {
public:
    std::expected<Student, Error> parse(const DbQueryResultRow& rowData) const override;
    DbQueryResultRow serialize(const Student& entity) const override; // Sẽ phức tạp hơn cho SQL, tạm thời để trống hoặc đơn giản hóa

    // Helper để serialize cho các câu lệnh SQL cụ thể hơn
    std::vector<DbQueryParam> serializeForInsert(const Student& student, const std::string& passwordHash, const std::string& salt) const;
    std::vector<DbQueryParam> serializeForUpdate(const Student& student) const;
};

#endif // SQLSTUDENTPARSER_H
```
--- END OF FILE SqlStudentParser.h ---

--- START OF FILE SqlStudentParser.cpp ---
```cpp
#include "SqlStudentParser.h"
#include "../../../../utils/StringUtils.h" // Cho trim nếu cần
#include <iostream> // Tạm

std::expected<Student, Error> SqlStudentParser::parse(const DbQueryResultRow& rowData) const {
    ValidationResult vr; // Dùng để thu thập lỗi parsing

    std::string id, firstName, lastName, facultyId, address, citizenId, email, phoneNumber;
    int bDay = 0, bMonth = 0, bYear = 0;
    LoginStatus status = LoginStatus::DISABLED; // Mặc định
    UserRole role = UserRole::UNKNOWN; // Mặc định

    // Giả sử các cột trong DbQueryResultRow có tên như sau:
    // Users table: id, firstName, lastName, birthDay, birthMonth, birthYear, address, citizenId, email, phoneNumber, role, status
    // Students table: userId (FK to Users.id), facultyId

    try {
        id = safe_any_cast<std::string>(rowData.at("userId"), "userId", vr); // userId từ bảng Students, cũng là id từ bảng Users
        firstName = safe_any_cast<std::string>(rowData.at("firstName"), "firstName", vr);
        lastName = safe_any_cast<std::string>(rowData.at("lastName"), "lastName", vr);
        facultyId = safe_any_cast<std::string>(rowData.at("facultyId"), "facultyId", vr);

        // Các trường tùy chọn, có thể NULL trong DB
        if (rowData.count("birthDay")) bDay = safe_any_cast<long>(rowData.at("birthDay"), "birthDay", vr, 0); // SQLite trả về long cho int
        if (rowData.count("birthMonth")) bMonth = safe_any_cast<long>(rowData.at("birthMonth"), "birthMonth", vr, 0);
        if (rowData.count("birthYear")) bYear = safe_any_cast<long>(rowData.at("birthYear"), "birthYear", vr, 0);
        if (rowData.count("address")) address = safe_any_cast<std::string>(rowData.at("address"), "address", vr, "");
        if (rowData.count("citizenId")) citizenId = safe_any_cast<std::string>(rowData.at("citizenId"), "citizenId", vr, "");
        if (rowData.count("email")) email = safe_any_cast<std::string>(rowData.at("email"), "email", vr, "");
        if (rowData.count("phoneNumber")) phoneNumber = safe_any_cast<std::string>(rowData.at("phoneNumber"), "phoneNumber", vr, "");
        
        if (rowData.count("status")) {
            status = static_cast<LoginStatus>(safe_any_cast<long>(rowData.at("status"), "status", vr, static_cast<long>(LoginStatus::DISABLED)));
        }
        // Role được set trong constructor Student, không cần lấy từ DB ở đây vì đã biết là Student.
        // Nếu là User chung thì mới cần lấy role.


        if (!vr.isValid) {
            return std::unexpected(Error{ErrorCode::PARSING_ERROR, "Error parsing Student data: " + vr.getErrorMessagesCombined()});
        }

        Student student(id, firstName, lastName, facultyId, status);
        if (bDay > 0 && bMonth > 0 && bYear > 0) { // Chỉ set nếu ngày sinh hợp lệ từ DB
            student.setBirthday(bDay, bMonth, bYear);
        }
        student.setAddress(address);
        student.setCitizenId(citizenId);
        student.setEmail(email);
        student.setPhoneNumber(phoneNumber);
        // student.setRole(role); // Role đã được Student constructor set

        return student;

    } catch (const std::out_of_range& oor) {
        return std::unexpected(Error{ErrorCode::PARSING_ERROR, "Missing required field in student data: " + std::string(oor.what())});
    } catch (const std::bad_any_cast& bac) {
         return std::unexpected(Error{ErrorCode::PARSING_ERROR, "Type mismatch in student data: " + std::string(bac.what())});
    }
}

// serialize() chung chung có thể không hữu ích cho SQL vì các cột thường được bind riêng lẻ
// hoặc serialize thành các DbQueryParam.
DbQueryResultRow SqlStudentParser::serialize(const Student& entity) const {
    DbQueryResultRow row;
    row["userId"] = entity.getId();
    row["firstName"] = entity.getFirstName();
    row["lastName"] = entity.getLastName();
    row["facultyId"] = entity.getFacultyId();
    if(entity.getBirthday().isSet()){
        row["birthDay"] = entity.getBirthday().getDay();
        row["birthMonth"] = entity.getBirthday().getMonth();
        row["birthYear"] = entity.getBirthday().getYear();
    } else {
        row["birthDay"] = std::any{};
        row["birthMonth"] = std::any{};
        row["birthYear"] = std::any{};
    }
    row["address"] = entity.getAddress().empty() ? std::any{} : std::any(entity.getAddress());
    row["citizenId"] = entity.getCitizenId().empty() ? std::any{} : std::any(entity.getCitizenId());
    row["email"] = entity.getEmail().empty() ? std::any{} : std::any(entity.getEmail());
    row["phoneNumber"] = entity.getPhoneNumber().empty() ? std::any{} : std::any(entity.getPhoneNumber());
    row["role"] = static_cast<long>(entity.getRole()); // UserRole là int
    row["status"] = static_cast<long>(entity.getStatus()); // LoginStatus là int
    return row;
}

std::vector<DbQueryParam> SqlStudentParser::serializeForInsert(const Student& student, const std::string& passwordHash, const std::string& salt) const {
    std::vector<DbQueryParam> params;
    // Bảng Users
    params.push_back(student.getId());
    params.push_back(student.getFirstName());
    params.push_back(student.getLastName());
    if (student.getBirthday().isSet()) {
        params.push_back(student.getBirthday().getDay());
        params.push_back(student.getBirthday().getMonth());
        params.push_back(student.getBirthday().getYear());
    } else {
        params.push_back(std::any{}); // NULL
        params.push_back(std::any{}); // NULL
        params.push_back(std::any{}); // NULL
    }
    params.push_back(student.getAddress().empty() ? std::any{} : student.getAddress());
    params.push_back(student.getCitizenId().empty() ? std::any{} : student.getCitizenId());
    params.push_back(student.getEmail().empty() ? std::any{} : student.getEmail());
    params.push_back(student.getPhoneNumber().empty() ? std::any{} : student.getPhoneNumber());
    params.push_back(static_cast<long>(student.getRole()));
    params.push_back(static_cast<long>(student.getStatus()));

    // Bảng Logins
    params.push_back(student.getId()); // userId
    params.push_back(passwordHash);
    params.push_back(salt);

    // Bảng Students
    params.push_back(student.getId()); // userId
    params.push_back(student.getFacultyId());
    return params;
}

std::vector<DbQueryParam> SqlStudentParser::serializeForUpdate(const Student& student) const {
    std::vector<DbQueryParam> params;
    // Bảng Users
    params.push_back(student.getFirstName());
    params.push_back(student.getLastName());
    if (student.getBirthday().isSet()) {
        params.push_back(student.getBirthday().getDay());
        params.push_back(student.getBirthday().getMonth());
        params.push_back(student.getBirthday().getYear());
    } else {
        params.push_back(std::any{});
        params.push_back(std::any{});
        params.push_back(std::any{});
    }
    params.push_back(student.getAddress().empty() ? std::any{} : student.getAddress());
    params.push_back(student.getCitizenId().empty() ? std::any{} : student.getCitizenId());
    params.push_back(student.getEmail().empty() ? std::any{} : student.getEmail());
    params.push_back(student.getPhoneNumber().empty() ? std::any{} : student.getPhoneNumber());
    // role và status được cập nhật riêng
    
    // Bảng Students
    params.push_back(student.getFacultyId());

    // ID cho WHERE clause (sẽ được thêm vào cuối cùng bởi DAO)
    params.push_back(student.getId()); // For Users table
    params.push_back(student.getId()); // For Students table (nếu cần update riêng)
    return params;
}
```
--- END OF FILE SqlStudentParser.cpp ---

--- START OF FILE SqlStudentDao.h ---
```cpp
#ifndef SQLSTUDENTDAO_H
#define SQLSTUDENTDAO_H

#include "../interface/IStudentDao.h"
#include "../../../database_adapter/interface/IDatabaseAdapter.h"
#include "../parsing/sql/SqlStudentParser.h" // (➕)
#include <memory>

class SqlStudentDao : public IStudentDao {
private:
    std::shared_ptr<IDatabaseAdapter> _dbAdapter;
    SqlStudentParser _parser; // (➕) Parser cụ thể

public:
    SqlStudentDao(std::shared_ptr<IDatabaseAdapter> dbAdapter);
    ~SqlStudentDao() override = default;

    std::expected<Student, Error> getById(const std::string& id) const override;
    std::expected<std::vector<Student>, Error> getAll() const override;
    std::expected<Student, Error> add(const Student& student) override; // Sẽ cần thêm passwordHash, salt
    std::expected<bool, Error> update(const Student& student) override;
    std::expected<bool, Error> remove(const std::string& id) override;
    std::expected<bool, Error> exists(const std::string& id) const override;

    std::expected<std::vector<Student>, Error> findByFacultyId(const std::string& facultyId) const override;
    std::expected<Student, Error> findByEmail(const std::string& email) const override;
    std::expected<std::vector<Student>, Error> findByStatus(LoginStatus status) const override;
    std::expected<bool, Error> updateStatus(const std::string& studentId, LoginStatus newStatus) override;
};

#endif // SQLSTUDENTDAO_H
```
--- END OF FILE SqlStudentDao.h ---

--- START OF FILE SqlStudentDao.cpp ---
```cpp
#include "SqlStudentDao.h"
#include "../../../../utils/Logger.h" // Để log lỗi

// Các hằng số cho tên bảng và cột
namespace StudentTable {
    const std::string TABLE_USERS = "Users";
    const std::string TABLE_STUDENTS = "Students";
    const std::string COL_USER_ID = "id"; // Users.id và Students.userId
    const std::string COL_FIRST_NAME = "firstName";
    const std::string COL_LAST_NAME = "lastName";
    const std::string COL_BIRTH_DAY = "birthDay";
    const std::string COL_BIRTH_MONTH = "birthMonth";
    const std::string COL_BIRTH_YEAR = "birthYear";
    const std::string COL_ADDRESS = "address";
    const std::string COL_CITIZEN_ID = "citizenId";
    const std::string COL_EMAIL = "email";
    const std::string COL_PHONE = "phoneNumber";
    const std::string COL_ROLE = "role";
    const std::string COL_STATUS = "status";
    const std::string COL_FACULTY_ID = "facultyId";
}

SqlStudentDao::SqlStudentDao(std::shared_ptr<IDatabaseAdapter> dbAdapter)
    : _dbAdapter(std::move(dbAdapter)) {
    if (!_dbAdapter) {
        LOG_CRITICAL("SqlStudentDao: IDatabaseAdapter is null.");
        throw std::runtime_error("SqlStudentDao: IDatabaseAdapter cannot be null.");
    }
}

std::expected<Student, Error> SqlStudentDao::getById(const std::string& id) const {
    std::string query = "SELECT u.*, s.facultyId FROM " + StudentTable::TABLE_USERS + " u JOIN " +
                        StudentTable::TABLE_STUDENTS + " s ON u." + StudentTable::COL_USER_ID + " = s." + StudentTable::COL_USER_ID +
                        " WHERE u." + StudentTable::COL_USER_ID + " = ?;";
    
    auto result = _dbAdapter->executeQuery(query, {id});
    if (!result.has_value()) {
        LOG_ERROR("SqlStudentDao::getById - Database error: " + result.error().message);
        return std::unexpected(result.error());
    }
    if (result.value().empty()) {
        return std::unexpected(Error{ErrorCode::NOT_FOUND, "Student with ID " + id + " not found."});
    }
    return _parser.parse(result.value()[0]);
}

std::expected<std::vector<Student>, Error> SqlStudentDao::getAll() const {
    std::string query = "SELECT u.*, s.facultyId FROM " + StudentTable::TABLE_USERS + " u JOIN " +
                        StudentTable::TABLE_STUDENTS + " s ON u." + StudentTable::COL_USER_ID + " = s." + StudentTable::COL_USER_ID + ";";
    
    auto result = _dbAdapter->executeQuery(query);
    if (!result.has_value()) {
        LOG_ERROR("SqlStudentDao::getAll - Database error: " + result.error().message);
        return std::unexpected(result.error());
    }
    std::vector<Student> students;
    for (const auto& row : result.value()) {
        auto student = _parser.parse(row);
        if (student.has_value()) {
            students.push_back(student.value());
        } else {
            LOG_WARN("SqlStudentDao::getAll - Failed to parse a student row: " + student.error().message);
            // Có thể quyết định trả về lỗi ngay hoặc bỏ qua hàng lỗi
        }
    }
    return students;
}

// Hàm add() này chỉ thêm thông tin vào bảng Users và Students.
// Việc thêm vào bảng Logins cần được xử lý ở một nơi khác (ví dụ AuthService hoặc LoginDao riêng)
// hoặc hàm này cần nhận thêm passwordHash và salt. Hiện tại, hàm này chưa hoàn chỉnh.
// Trong thiết kế thực tế, AuthService sẽ gọi LoginDao::addUserCredentials và StudentDao::add.
// Để đơn giản cho ví dụ này, ta giả định add() của DAO không xử lý Logins.
std::expected<Student, Error> SqlStudentDao::add(const Student& student) {
     // Kiểm tra xem student đã tồn tại chưa qua email hoặc citizenId hoặc id
    auto existCheckId = exists(student.getId());
    if (!existCheckId.has_value()) return std::unexpected(existCheckId.error());
    if (existCheckId.value()) return std::unexpected(Error{ErrorCode::ALREADY_EXISTS, "Student with ID " + student.getId() + " already exists."});
    
    auto existCheckEmail = findByEmail(student.getEmail());
    if (existCheckEmail.has_value()) return std::unexpected(Error{ErrorCode::ALREADY_EXISTS, "Student with email " + student.getEmail() + " already exists."});
    if (existCheckEmail.error().code != ErrorCode::NOT_FOUND) return std::unexpected(existCheckEmail.error());


    std::string userInsertQuery = "INSERT INTO " + StudentTable::TABLE_USERS +
                                  " (id, firstName, lastName, birthDay, birthMonth, birthYear, address, citizenId, email, phoneNumber, role, status) " +
                                  "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);";
    std::string studentInsertQuery = "INSERT INTO " + StudentTable::TABLE_STUDENTS + " (userId, facultyId) VALUES (?, ?);";

    if (!_dbAdapter->beginTransaction().has_value()) {
        return std::unexpected(Error{ErrorCode::DATA_ACCESS_ERROR, "Failed to begin transaction for adding student."});
    }

    std::vector<DbQueryParam> userParams;
    userParams.push_back(student.getId());
    userParams.push_back(student.getFirstName());
    userParams.push_back(student.getLastName());
    if (student.getBirthday().isSet()) {
        userParams.push_back(student.getBirthday().getDay());
        userParams.push_back(student.getBirthday().getMonth());
        userParams.push_back(student.getBirthday().getYear());
    } else {
        userParams.push_back(std::any{}); params.push_back(std::any{}); params.push_back(std::any{});
    }
    userParams.push_back(student.getAddress().empty() ? std::any{} : student.getAddress());
    userParams.push_back(student.getCitizenId().empty() ? std::any{} : student.getCitizenId());
    userParams.push_back(student.getEmail().empty() ? std::any{} : student.getEmail());
    userParams.push_back(student.getPhoneNumber().empty() ? std::any{} : student.getPhoneNumber());
    userParams.push_back(static_cast<long>(student.getRole()));
    userParams.push_back(static_cast<long>(student.getStatus()));

    auto userResult = _dbAdapter->executeUpdate(userInsertQuery, userParams);
    if (!userResult.has_value() || userResult.value() == 0) {
        _dbAdapter->rollbackTransaction();
        return std::unexpected(Error{ErrorCode::OPERATION_FAILED, "Failed to insert into Users table: " + (userResult.has_value() ? "0 rows affected" : userResult.error().message)});
    }

    std::vector<DbQueryParam> studentParams = {student.getId(), student.getFacultyId()};
    auto studentResult = _dbAdapter->executeUpdate(studentInsertQuery, studentParams);
    if (!studentResult.has_value() || studentResult.value() == 0) {
        _dbAdapter->rollbackTransaction();
        return std::unexpected(Error{ErrorCode::OPERATION_FAILED, "Failed to insert into Students table: " + (studentResult.has_value() ? "0 rows affected" : studentResult.error().message)});
    }

    if (!_dbAdapter->commitTransaction().has_value()) {
         return std::unexpected(Error{ErrorCode::DATA_ACCESS_ERROR, "Failed to commit transaction for adding student."});
    }
    return student;
}

std::expected<bool, Error> SqlStudentDao::update(const Student& student) {
    std::string userUpdateQuery = "UPDATE " + StudentTable::TABLE_USERS + " SET " +
                                  StudentTable::COL_FIRST_NAME + " = ?, " + StudentTable::COL_LAST_NAME + " = ?, " +
                                  StudentTable::COL_BIRTH_DAY + " = ?, " + StudentTable::COL_BIRTH_MONTH + " = ?, " + StudentTable::COL_BIRTH_YEAR + " = ?, " +
                                  StudentTable::COL_ADDRESS + " = ?, " + StudentTable::COL_CITIZEN_ID + " = ?, " +
                                  StudentTable::COL_EMAIL + " = ?, " + StudentTable::COL_PHONE + " = ? " +
                                  // COL_ROLE and COL_STATUS updated by separate methods
                                  "WHERE " + StudentTable::COL_USER_ID + " = ?;";
    std::string studentUpdateQuery = "UPDATE " + StudentTable::TABLE_STUDENTS + " SET " +
                                     StudentTable::COL_FACULTY_ID + " = ? WHERE " + StudentTable::COL_USER_ID + " = ?;";
    
    if (!_dbAdapter->beginTransaction().has_value()) {
        return std::unexpected(Error{ErrorCode::DATA_ACCESS_ERROR, "Failed to begin transaction for updating student."});
    }

    std::vector<DbQueryParam> userParams;
    userParams.push_back(student.getFirstName());
    userParams.push_back(student.getLastName());
     if (student.getBirthday().isSet()) {
        userParams.push_back(student.getBirthday().getDay());
        userParams.push_back(student.getBirthday().getMonth());
        userParams.push_back(student.getBirthday().getYear());
    } else {
        userParams.push_back(std::any{}); userParams.push_back(std::any{}); userParams.push_back(std::any{});
    }
    userParams.push_back(student.getAddress().empty() ? std::any{} : student.getAddress());
    userParams.push_back(student.getCitizenId().empty() ? std::any{} : student.getCitizenId());
    userParams.push_back(student.getEmail().empty() ? std::any{} : student.getEmail());
    userParams.push_back(student.getPhoneNumber().empty() ? std::any{} : student.getPhoneNumber());
    userParams.push_back(student.getId());

    auto userResult = _dbAdapter->executeUpdate(userUpdateQuery, userParams);
     if (!userResult.has_value()) { // 0 rows affected is ok if data hasn't changed
        _dbAdapter->rollbackTransaction();
        return std::unexpected(Error{ErrorCode::OPERATION_FAILED, "Failed to update Users table: " + userResult.error().message});
    }

    std::vector<DbQueryParam> studentParams = {student.getFacultyId(), student.getId()};
    auto studentResult = _dbAdapter->executeUpdate(studentUpdateQuery, studentParams);
    if (!studentResult.has_value()) {
        _dbAdapter->rollbackTransaction();
        return std::unexpected(Error{ErrorCode::OPERATION_FAILED, "Failed to update Students table: " + studentResult.error().message});
    }
    
    if (!_dbAdapter->commitTransaction().has_value()) {
         return std::unexpected(Error{ErrorCode::DATA_ACCESS_ERROR, "Failed to commit transaction for updating student."});
    }
    return (userResult.value() > 0 || studentResult.value() > 0); // True if anything was updated
}

std::expected<bool, Error> SqlStudentDao::remove(const std::string& id) {
    // Nhớ rằng xóa từ Users sẽ tự động xóa từ Students, Logins, Enrollments, CourseResults, FeeRecords do ON DELETE CASCADE
    std::string query = "DELETE FROM " + StudentTable::TABLE_USERS + " WHERE " + StudentTable::COL_USER_ID + " = ?;";
    auto result = _dbAdapter->executeUpdate(query, {id});
    if (!result.has_value()) {
        return std::unexpected(result.error());
    }
    if (result.value() == 0) {
        return std::unexpected(Error{ErrorCode::NOT_FOUND, "Student with ID " + id + " not found for removal."});
    }
    return true;
}

std::expected<bool, Error> SqlStudentDao::exists(const std::string& id) const {
    auto student = getById(id);
    if (student.has_value()) return true;
    if (student.error().code == ErrorCode::NOT_FOUND) return false;
    return std::unexpected(student.error());
}

std::expected<std::vector<Student>, Error> SqlStudentDao::findByFacultyId(const std::string& facultyId) const {
    std::string query = "SELECT u.*, s.facultyId FROM " + StudentTable::TABLE_USERS + " u JOIN " +
                        StudentTable::TABLE_STUDENTS + " s ON u." + StudentTable::COL_USER_ID + " = s." + StudentTable::COL_USER_ID +
                        " WHERE s." + StudentTable::COL_FACULTY_ID + " = ?;";
    
    auto result = _dbAdapter->executeQuery(query, {facultyId});
    if (!result.has_value()) {
        return std::unexpected(result.error());
    }
    std::vector<Student> students;
    for (const auto& row : result.value()) {
        auto student = _parser.parse(row);
        if (student.has_value()) {
            students.push_back(student.value());
        } else {
             LOG_WARN("SqlStudentDao::findByFacultyId - Failed to parse a student row: " + student.error().message);
        }
    }
    return students;
}

std::expected<Student, Error> SqlStudentDao::findByEmail(const std::string& email) const {
    std::string query = "SELECT u.*, s.facultyId FROM " + StudentTable::TABLE_USERS + " u JOIN " +
                        StudentTable::TABLE_STUDENTS + " s ON u." + StudentTable::COL_USER_ID + " = s." + StudentTable::COL_USER_ID +
                        " WHERE u." + StudentTable::COL_EMAIL + " = ?;";
    auto result = _dbAdapter->executeQuery(query, {email});
    if (!result.has_value()) {
        return std::unexpected(result.error());
    }
    if (result.value().empty()) {
        return std::unexpected(Error{ErrorCode::NOT_FOUND, "Student with email " + email + " not found."});
    }
    return _parser.parse(result.value()[0]);
}

std::expected<std::vector<Student>, Error> SqlStudentDao::findByStatus(LoginStatus status) const {
    std::string query = "SELECT u.*, s.facultyId FROM " + StudentTable::TABLE_USERS + " u JOIN " +
                        StudentTable::TABLE_STUDENTS + " s ON u." + StudentTable::COL_USER_ID + " = s." + StudentTable::COL_USER_ID +
                        " WHERE u." + StudentTable::COL_STATUS + " = ?;";
    auto result = _dbAdapter->executeQuery(query, {static_cast<long>(status)});
     if (!result.has_value()) {
        return std::unexpected(result.error());
    }
    std::vector<Student> students;
    for (const auto& row : result.value()) {
        auto student = _parser.parse(row);
        if (student.has_value()) {
            students.push_back(student.value());
        } else {
            LOG_WARN("SqlStudentDao::findByStatus - Failed to parse a student row: " + student.error().message);
        }
    }
    return students;
}

std::expected<bool, Error> SqlStudentDao::updateStatus(const std::string& studentId, LoginStatus newStatus) {
    std::string query = "UPDATE " + StudentTable::TABLE_USERS + " SET " + StudentTable::COL_STATUS + " = ? WHERE " +
                        StudentTable::COL_USER_ID + " = ?;";
    auto result = _dbAdapter->executeUpdate(query, {static_cast<long>(newStatus), studentId});
    if (!result.has_value()) {
        return std::unexpected(result.error());
    }
    if (result.value() == 0) {
        return std::unexpected(Error{ErrorCode::NOT_FOUND, "Student with ID " + studentId + " not found for status update."});
    }
    return true;
}
```
--- END OF FILE SqlStudentDao.cpp ---

--- START OF FILE DaoFactory.cpp ---
```cpp
#include "DaoFactory.h"
#include "../../utils/Logger.h"
// Mock DAOs
#include "mock/MockStudentDao.h"
#include "mock/MockTeacherDao.h"
#include "mock/MockFacultyDao.h"
#include "mock/MockCourseDao.h"
#include "mock/MockEnrollmentDao.h"
#include "mock/MockCourseResultDao.h"
#include "mock/MockFeeRecordDao.h"
#include "mock/MockSalaryRecordDao.h"
#include "mock/MockLoginDao.h"

// SQL DAOs (Sẽ thêm dần)
#include "sql/SqlStudentDao.h"
#include "sql/SqlTeacherDao.h"
#include "sql/SqlFacultyDao.h"
#include "sql/SqlCourseDao.h"
#include "sql/SqlEnrollmentDao.h"
#include "sql/SqlCourseResultDao.h"
#include "sql/SqlFeeRecordDao.h"
#include "sql/SqlSalaryRecordDao.h"
#include "sql/SqlLoginDao.h"


// Database Adapter (Chỉ cần 1 instance cho SQL)
#include "../database_adapter/sql/SQLiteAdapter.h" // (➕)
// File Handler (Chỉ cần 1 instance cho CSV)
#include "../../utils/TextFileHandler.h" // (➕) Giả sử có file này

// Parsers (Mỗi CSV DAO cần parser của nó, SQL DAO cũng vậy)
// CSV Parsers (Ví dụ)
// #include "../parsing/csv/CsvStudentParser.h"
// SQL Parsers (Ví dụ)
#include "../parsing/sql/SqlStudentParser.h"
// ... include các SQL parser khác


// (➕) File Handler instance
std::shared_ptr<IFileHandler> DaoFactory::getFileHandlerInstance() {
    static std::shared_ptr<IFileHandler> fileHandler = std::make_shared<TextFileHandler>();
    return fileHandler;
}

// (➕) DB Adapter instance
std::shared_ptr<IDatabaseAdapter> DaoFactory::getDatabaseAdapterInstance(const AppConfig& config) {
    static std::shared_ptr<IDatabaseAdapter> dbAdapter = nullptr;
    static std::string currentConnectionString;

    if (config.dataSourceType == DataSourceType::SQL) {
        if (!dbAdapter || config.sqlConnectionString != currentConnectionString) {
            // Tạo mới hoặc tạo lại nếu connection string thay đổi
            auto sqliteAdapter = std::make_shared<SQLiteAdapter>();
            auto connectResult = sqliteAdapter->connect(config.sqlConnectionString);
            if (!connectResult.has_value()) {
                LOG_CRITICAL("DaoFactory: Failed to connect to SQLite database: " + connectResult.error().message);
                // Có thể throw exception hoặc trả về nullptr, tùy chiến lược xử lý lỗi
                return nullptr;
            }
            // Quan trọng: Đảm bảo bảng tồn tại
            auto tableEnsureResult = sqliteAdapter->ensureTablesExist();
             if (!tableEnsureResult.has_value()) {
                LOG_CRITICAL("DaoFactory: Failed to ensure SQLite tables exist: " + tableEnsureResult.error().message);
                sqliteAdapter->disconnect();
                return nullptr;
            }

            dbAdapter = sqliteAdapter;
            currentConnectionString = config.sqlConnectionString;
            LOG_INFO("DaoFactory: SQLiteAdapter instance created and connected to " + config.sqlConnectionString);
        }
    } else {
        // Nếu không phải SQL, có thể reset dbAdapter nếu cần
        if (dbAdapter && dbAdapter->isConnected()) {
            dbAdapter->disconnect();
        }
        dbAdapter.reset();
        currentConnectionString.clear();
    }
    return dbAdapter;
}


// (➕) CSV Parser instances (Template-based helper)
template<typename TEntity>
std::shared_ptr<IEntityParser<TEntity, std::vector<std::string>>> DaoFactory::getCsvRowParserInstance() {
    // Cần triển khai cụ thể cho từng Entity
    // Ví dụ:
    // if constexpr (std::is_same_v<TEntity, Student>) {
    //     static std::shared_ptr<IEntityParser<Student, std::vector<std::string>>> parser = std::make_shared<CsvStudentParser>();
    //     return parser;
    // }
    // ...
    LOG_ERROR("DaoFactory::getCsvRowParserInstance - No CSV parser for the given entity type.");
    return nullptr; // Hoặc throw
}

// (➕) SQL Parser instances (Template-based helper)
template<typename TEntity, typename TDbRow = DbQueryResultRow> // TDbRow có thể được chuyên biệt hóa
std::shared_ptr<IEntityParser<TEntity, TDbRow>> DaoFactory::getSqlRowParserInstance() {
    // Cần triển khai cụ thể cho từng Entity
    if constexpr (std::is_same_v<TEntity, Student>) {
        // SQL parser có thể không cần là singleton nếu nó stateless
        return std::make_shared<SqlStudentParser>();
    }
    // ... các entity khác
    LOG_ERROR("DaoFactory::getSqlRowParserInstance - No SQL parser for the given entity type.");
    return nullptr; // Hoặc throw
}


std::shared_ptr<IStudentDao> DaoFactory::createStudentDao(const AppConfig& config) {
    switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockStudentDao.");
            return std::make_shared<MockStudentDao>();
        case DataSourceType::CSV:
            LOG_ERROR("DaoFactory: CSVStudentDao not yet implemented.");
            // return std::make_shared<CsvStudentDao>(config.csvFilePaths.at(EntityType::STUDENT), getCsvRowParserInstance<Student>(), getFileHandlerInstance());
            return nullptr;
        case DataSourceType::SQL:
            {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlStudentDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlStudentDao.");
                return std::make_shared<SqlStudentDao>(adapter);
            }
        default:
            LOG_ERROR("DaoFactory: Unknown data source type for StudentDao.");
            return nullptr;
    }
}

std::shared_ptr<ITeacherDao> DaoFactory::createTeacherDao(const AppConfig& config) {
    switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockTeacherDao.");
            return std::make_shared<MockTeacherDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlTeacherDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlTeacherDao.");
                // return std::make_shared<SqlTeacherDao>(adapter, getSqlRowParserInstance<Teacher>());
                // Tạm thời trả về null cho đến khi SqlTeacherDao và parser của nó được implement
                LOG_WARN("DaoFactory: SqlTeacherDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: TeacherDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<IFacultyDao> DaoFactory::createFacultyDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockFacultyDao.");
            return std::make_shared<MockFacultyDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlFacultyDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlFacultyDao.");
                // return std::make_shared<SqlFacultyDao>(adapter, getSqlRowParserInstance<Faculty>());
                LOG_WARN("DaoFactory: SqlFacultyDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: FacultyDao for specified type not implemented.");
            return nullptr;
    }
}
std::shared_ptr<ICourseDao> DaoFactory::createCourseDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockCourseDao.");
            return std::make_shared<MockCourseDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlCourseDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlCourseDao.");
                // return std::make_shared<SqlCourseDao>(adapter, getSqlRowParserInstance<Course>());
                LOG_WARN("DaoFactory: SqlCourseDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: CourseDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<IEnrollmentDao> DaoFactory::createEnrollmentDao(const AppConfig& config) {
    switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockEnrollmentDao.");
            return std::make_shared<MockEnrollmentDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlEnrollmentDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlEnrollmentDao.");
                // SqlEnrollmentDao không dùng parser entity, nó làm việc trực tiếp với ID hoặc EnrollmentRecord struct
                // return std::make_shared<SqlEnrollmentDao>(adapter);
                LOG_WARN("DaoFactory: SqlEnrollmentDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: EnrollmentDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<ICourseResultDao> DaoFactory::createCourseResultDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockCourseResultDao.");
            return std::make_shared<MockCourseResultDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlCourseResultDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlCourseResultDao.");
                // return std::make_shared<SqlCourseResultDao>(adapter, getSqlRowParserInstance<CourseResult>());
                LOG_WARN("DaoFactory: SqlCourseResultDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: CourseResultDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<IFeeRecordDao> DaoFactory::createFeeRecordDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockFeeRecordDao.");
            return std::make_shared<MockFeeRecordDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlFeeRecordDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlFeeRecordDao.");
                // return std::make_shared<SqlFeeRecordDao>(adapter, getSqlRowParserInstance<FeeRecord>());
                LOG_WARN("DaoFactory: SqlFeeRecordDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: FeeRecordDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<ISalaryRecordDao> DaoFactory::createSalaryRecordDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockSalaryRecordDao.");
            return std::make_shared<MockSalaryRecordDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlSalaryRecordDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlSalaryRecordDao.");
                // return std::make_shared<SqlSalaryRecordDao>(adapter, getSqlRowParserInstance<SalaryRecord>());
                LOG_WARN("DaoFactory: SqlSalaryRecordDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: SalaryRecordDao for specified type not implemented.");
            return nullptr;
    }
}

std::shared_ptr<ILoginDao> DaoFactory::createLoginDao(const AppConfig& config) {
     switch (config.dataSourceType) {
        case DataSourceType::MOCK:
            LOG_INFO("DaoFactory: Creating MockLoginDao.");
            return std::make_shared<MockLoginDao>();
        case DataSourceType::SQL:
             {
                auto adapter = getDatabaseAdapterInstance(config);
                if (!adapter) {
                     LOG_ERROR("DaoFactory: Failed to get DatabaseAdapter for SqlLoginDao.");
                     return nullptr;
                }
                LOG_INFO("DaoFactory: Creating SqlLoginDao.");
                // LoginDao có thể không cần parser Entity chung, mà là parser cho LoginCredentials
                // return std::make_shared<SqlLoginDao>(adapter);
                LOG_WARN("DaoFactory: SqlLoginDao not fully implemented yet, returning nullptr.");
                return nullptr;
            }
        default:
            LOG_ERROR("DaoFactory: LoginDao for specified type not implemented.");
            return nullptr;
    }
}
```
--- END OF FILE DaoFactory.cpp ---

--- START OF FILE TextFileHandler.h ---
```cpp
#ifndef TEXTFILEHANDLER_H
#define TEXTFILEHANDLER_H

#include "IFileHandler.h"

class TextFileHandler : public IFileHandler {
public:
    OperationResult<std::vector<std::string>> readAllLines(const std::filesystem::path& filePath) const override;
    OperationResult<bool> writeAllLines(const std::filesystem::path& filePath, const std::vector<std::string>& lines) const override;
    OperationResult<bool> appendLine(const std::filesystem::path& filePath, const std::string& line) const override;
    bool fileExists(const std::filesystem::path& filePath) const override;
    bool ensureDirectoryExists(const std::filesystem::path& dirPath) const override;
};

#endif // TEXTFILEHANDLER_H
```
--- END OF FILE TextFileHandler.h ---

--- START OF FILE TextFileHandler.cpp ---
```cpp
#include "TextFileHandler.h"
#include <fstream>
#include <sstream>
#include "Logger.h" // Để log lỗi

OperationResult<std::vector<std::string>> TextFileHandler::readAllLines(const std::filesystem::path& filePath) const {
    std::vector<std::string> lines;
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::string errMsg = "Failed to open file for reading: " + filePath.string();
        LOG_ERROR("TextFileHandler::readAllLines - " + errMsg);
        return OperationResult<std::vector<std::string>>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    std::string line;
    while (std::getline(file, line)) {
        lines.push_back(line);
    }
    file.close();
    return OperationResult<std::vector<std::string>>::success(lines);
}

OperationResult<bool> TextFileHandler::writeAllLines(const std::filesystem::path& filePath, const std::vector<std::string>& lines) const {
    if (!ensureDirectoryExists(filePath.parent_path())) {
        std::string errMsg = "Failed to ensure directory exists for: " + filePath.string();
        LOG_ERROR("TextFileHandler::writeAllLines - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    std::ofstream file(filePath, std::ios::trunc); // Mở và xóa nội dung cũ (overwrite)
    if (!file.is_open()) {
        std::string errMsg = "Failed to open file for writing: " + filePath.string();
        LOG_ERROR("TextFileHandler::writeAllLines - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    for (const auto& line : lines) {
        file << line << std::endl;
    }
    file.close();
    if (!file) { // Kiểm tra lỗi ghi sau khi đóng
        std::string errMsg = "Error occurred during writing to file: " + filePath.string();
        LOG_ERROR("TextFileHandler::writeAllLines - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    return OperationResult<bool>::success(true);
}

OperationResult<bool> TextFileHandler::appendLine(const std::filesystem::path& filePath, const std::string& line) const {
    if (!ensureDirectoryExists(filePath.parent_path())) {
         std::string errMsg = "Failed to ensure directory exists for: " + filePath.string();
        LOG_ERROR("TextFileHandler::appendLine - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    std::ofstream file(filePath, std::ios::app); // Mở ở chế độ append
    if (!file.is_open()) {
        std::string errMsg = "Failed to open file for appending: " + filePath.string();
        LOG_ERROR("TextFileHandler::appendLine - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    file << line << std::endl;
    file.close();
    if (!file) {
        std::string errMsg = "Error occurred during appending to file: " + filePath.string();
        LOG_ERROR("TextFileHandler::appendLine - " + errMsg);
        return OperationResult<bool>::failure(errMsg, ErrorCode::DATA_ACCESS_ERROR);
    }
    return OperationResult<bool>::success(true);
}

bool TextFileHandler::fileExists(const std::filesystem::path& filePath) const {
    return std::filesystem::exists(filePath) && std::filesystem::is_regular_file(filePath);
}

bool TextFileHandler::ensureDirectoryExists(const std::filesystem::path& dirPath) const {
    if (dirPath.empty()) return true; // Không có đường dẫn cha (ví dụ: file ở thư mục hiện tại)
    if (std::filesystem::exists(dirPath)) {
        if (std::filesystem::is_directory(dirPath)) {
            return true;
        }
        LOG_ERROR("TextFileHandler::ensureDirectoryExists - Path exists but is not a directory: " + dirPath.string());
        return false; // Tồn tại nhưng không phải thư mục
    }
    try {
        return std::filesystem::create_directories(dirPath);
    } catch (const std::filesystem::filesystem_error& e) {
        LOG_ERROR("TextFileHandler::ensureDirectoryExists - Filesystem error creating directory " + dirPath.string() + ": " + e.what());
        return false;
    }
}
```
--- END OF FILE TextFileHandler.cpp ---

--- START OF FILE PasswordValidator.h ---
```cpp
#ifndef PASSWORDVALIDATOR_H
#define PASSWORDVALIDATOR_H

#include "../interface/IValidator.h"
#include <string>

class PasswordValidator { // Không kế thừa IEntityValidator vì nó validate input string
public:
    PasswordValidator(size_t minLength = 8, bool requireUpper = true, bool requireLower = true, bool requireDigit = true, bool requireSymbol = false);
    ValidationResult validate(const std::string& password) const;

private:
    size_t _minLength;
    bool _requireUpper;
    bool _requireLower;
    bool _requireDigit;
    bool _requireSymbol;
};

#endif // PASSWORDVALIDATOR_H
```
--- END OF FILE PasswordValidator.h ---

--- START OF FILE PasswordValidator.cpp ---
```cpp
#include "PasswordValidator.h"
#include <cctype> // For isupper, islower, isdigit, ispunct

PasswordValidator::PasswordValidator(size_t minLength, bool requireUpper, bool requireLower, bool requireDigit, bool requireSymbol)
    : _minLength(minLength), _requireUpper(requireUpper), _requireLower(requireLower), _requireDigit(requireDigit), _requireSymbol(requireSymbol) {}

ValidationResult PasswordValidator::validate(const std::string& password) const {
    ValidationResult vr;

    if (password.length() < _minLength) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Password must be at least " + std::to_string(_minLength) + " characters long.");
    }

    bool hasUpper = false;
    bool hasLower = false;
    bool hasDigit = false;
    bool hasSymbol = false;

    for (char c : password) {
        if (std::isupper(static_cast<unsigned char>(c))) hasUpper = true;
        else if (std::islower(static_cast<unsigned char>(c))) hasLower = true;
        else if (std::isdigit(static_cast<unsigned char>(c))) hasDigit = true;
        else if (std::ispunct(static_cast<unsigned char>(c))) hasSymbol = true; // ispunct bao gồm các ký tự đặc biệt
    }

    if (_requireUpper && !hasUpper) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Password must contain at least one uppercase letter.");
    }
    if (_requireLower && !hasLower) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Password must contain at least one lowercase letter.");
    }
    if (_requireDigit && !hasDigit) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Password must contain at least one digit.");
    }
    if (_requireSymbol && !hasSymbol) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Password must contain at least one special character.");
    }

    return vr;
}
```
--- END OF FILE PasswordValidator.cpp ---

--- START OF FILE AuthService.h ---
```cpp
#ifndef AUTHSERVICE_H
#define AUTHSERVICE_H

#include "../interface/IAuthService.h"
#include "../../data_access/interface/ILoginDao.h"
#include "../../data_access/interface/IStudentDao.h" // (➕) Để tạo Student khi đăng ký
#include "../../data_access/interface/ITeacherDao.h" // (➕) Để lấy thông tin Teacher
#include "../../data_access/interface/IFacultyDao.h" // (➕) Để kiểm tra Faculty tồn tại khi đăng ký SV
#include "../../../utils/PasswordInput.h"         // (➕) Để hash và verify password
#include "../validators/impl/PasswordValidator.h" // (➕) Để validate password mới
#include "../validators/impl/StudentValidator.h" // (➕) Để validate StudentRegistrationData
#include "../../session/SessionContext.h"     // (➕) Để quản lý user hiện tại
#include <memory>

class AuthService : public IAuthService {
private:
    std::shared_ptr<ILoginDao> _loginDao;
    std::shared_ptr<IStudentDao> _studentDao; // (➕)
    std::shared_ptr<ITeacherDao> _teacherDao; // (➕)
    std::shared_ptr<IFacultyDao> _facultyDao; // (➕)
    PasswordValidator _passwordValidator;     // (➕)
    // StudentValidator _studentValidator;    // (➕) Không cần thiết nếu dùng Student::validateBasic() và các check khác
    SessionContext& _sessionContext;          // (➕) Tham chiếu tới SessionContext

    std::shared_ptr<User> fetchUserDetails(const std::string& userId, UserRole role) const;

public:
    AuthService(std::shared_ptr<ILoginDao> loginDao,
                std::shared_ptr<IStudentDao> studentDao,
                std::shared_ptr<ITeacherDao> teacherDao,
                std::shared_ptr<IFacultyDao> facultyDao,
                SessionContext& sessionContext);

    OperationResult<std::shared_ptr<User>> login(const std::string& userIdOrEmail, const std::string& password) override;
    void logout() override;
    bool isAuthenticated() const override;
    std::optional<std::string> getCurrentUserId() const override;
    std::optional<UserRole> getCurrentUserRole() const override;
    std::optional<std::shared_ptr<User>> getCurrentUser() const override;
    OperationResult<bool> registerStudent(const StudentRegistrationData& data, const std::string& plainPassword) override;
    OperationResult<bool> changePassword(const std::string& currentUserId, const std::string& oldPassword, const std::string& newPassword) override;
};

#endif // AUTHSERVICE_H
```
--- END OF FILE AuthService.h ---

--- START OF FILE AuthService.cpp ---
```cpp
#include "AuthService.h"
#include "../../../utils/Logger.h"
#include "../../entities/Student.h" // Để tạo Student
#include <regex> // Để kiểm tra email

AuthService::AuthService(std::shared_ptr<ILoginDao> loginDao,
                         std::shared_ptr<IStudentDao> studentDao,
                         std::shared_ptr<ITeacherDao> teacherDao,
                         std::shared_ptr<IFacultyDao> facultyDao,
                         SessionContext& sessionContext)
    : _loginDao(loginDao), _studentDao(studentDao), _teacherDao(teacherDao), _facultyDao(facultyDao),
      _passwordValidator(8, true, true, true, false), // Cấu hình validator password
      _sessionContext(sessionContext) {
    if (!_loginDao) LOG_CRITICAL("AuthService: ILoginDao is null.");
    if (!_studentDao) LOG_CRITICAL("AuthService: IStudentDao is null.");
    if (!_teacherDao) LOG_CRITICAL("AuthService: ITeacherDao is null.");
    if (!_facultyDao) LOG_CRITICAL("AuthService: IFacultyDao is null.");
}

std::shared_ptr<User> AuthService::fetchUserDetails(const std::string& userId, UserRole role) const {
    if (role == UserRole::STUDENT || role == UserRole::PENDING_STUDENT) {
        auto studentResult = _studentDao->getById(userId);
        if (studentResult.has_value()) {
            return std::make_shared<Student>(studentResult.value());
        }
         LOG_WARN("AuthService::fetchUserDetails - Could not fetch student details for ID: " + userId + ", Error: " + studentResult.error().message);
    } else if (role == UserRole::TEACHER) {
        auto teacherResult = _teacherDao->getById(userId);
        if (teacherResult.has_value()) {
            return std::make_shared<Teacher>(teacherResult.value());
        }
        LOG_WARN("AuthService::fetchUserDetails - Could not fetch teacher details for ID: " + userId + ", Error: " + teacherResult.error().message);
    } else if (role == UserRole::ADMIN) {
        // Admin có thể không có entity riêng, chỉ là User với role ADMIN
        // Hoặc có thể tạo một Admin entity đơn giản
        return std::make_shared<User>(userId, "Admin", "User", UserRole::ADMIN, LoginStatus::ACTIVE);
    }
    LOG_WARN("AuthService::fetchUserDetails - Unknown role or failed to fetch details for User ID: " + userId);
    return nullptr;
}


OperationResult<std::shared_ptr<User>> AuthService::login(const std::string& userIdOrEmail, const std::string& password) {
    if (_sessionContext.isAuthenticated()) {
        return OperationResult<std::shared_ptr<User>>::failure("User already logged in.", ErrorCode::OPERATION_FAILED);
    }

    std::string userIdToLogin = userIdOrEmail;
    // Kiểm tra xem userIdOrEmail có phải là email không
    // Regex đơn giản, có thể cải thiện
    const std::regex emailRegex(R"((\w+)(\.|_)?(\w*)@(\w+)(\.(\w+))+)");
    if (std::regex_match(userIdOrEmail, emailRegex)) {
        // Tìm student ID từ email
        auto studentByEmail = _studentDao->findByEmail(userIdOrEmail);
        if (studentByEmail.has_value()) {
            userIdToLogin = studentByEmail.value().getId();
        } else {
            // Tìm teacher ID từ email
            auto teacherByEmail = _teacherDao->findByEmail(userIdOrEmail);
            if (teacherByEmail.has_value()) {
                userIdToLogin = teacherByEmail.value().getId();
            } else {
                 if (studentByEmail.error().code != ErrorCode::NOT_FOUND || teacherByEmail.error().code != ErrorCode::NOT_FOUND) {
                    LOG_ERROR("AuthService::login - DB error finding user by email " + userIdOrEmail);
                    return OperationResult<std::shared_ptr<User>>::failure("Database error during login.", ErrorCode::DATA_ACCESS_ERROR);
                 }
                // Không tìm thấy user với email này
                LOG_WARN("AuthService::login - No user found with email: " + userIdOrEmail);
                return OperationResult<std::shared_ptr<User>>::failure("Invalid credentials.", ErrorCode::AUTHENTICATION_FAILED);
            }
        }
    }
    // Nếu không phải email, giả sử đó là userId


    auto credsResult = _loginDao->findCredentialsByUserId(userIdToLogin);
    if (!credsResult.has_value()) {
        if (credsResult.error().code == ErrorCode::NOT_FOUND) {
            LOG_WARN("AuthService::login - User ID not found: " + userIdToLogin);
        } else {
            LOG_ERROR("AuthService::login - DB error fetching credentials for " + userIdToLogin + ": " + credsResult.error().message);
        }
        return OperationResult<std::shared_ptr<User>>::failure("Invalid credentials.", ErrorCode::AUTHENTICATION_FAILED);
    }

    const LoginCredentials& creds = credsResult.value();

    if (creds.status == LoginStatus::DISABLED) {
        LOG_WARN("AuthService::login - Account disabled for User ID: " + userIdToLogin);
        return OperationResult<std::shared_ptr<User>>::failure("Account is disabled.", ErrorCode::AUTHENTICATION_FAILED);
    }
    if (creds.status == LoginStatus::PENDING_APPROVAL && creds.role != UserRole::ADMIN) { // Admin có thể login dù PENDING (nếu có logic đó)
        LOG_WARN("AuthService::login - Account pending approval for User ID: " + userIdToLogin);
        return OperationResult<std::shared_ptr<User>>::failure("Account is pending approval.", ErrorCode::AUTHENTICATION_FAILED);
    }

    if (!PasswordUtils::verifyPassword(password, creds.passwordHash, creds.salt)) {
        LOG_WARN("AuthService::login - Password verification failed for User ID: " + userIdToLogin);
        return OperationResult<std::shared_ptr<User>>::failure("Invalid credentials.", ErrorCode::AUTHENTICATION_FAILED);
    }

    // Lấy thông tin chi tiết của User
    std::shared_ptr<User> userDetails = fetchUserDetails(userIdToLogin, creds.role);
    if (!userDetails) {
        // Nếu không fetch được user details (dù creds có), đây là lỗi hệ thống
        LOG_ERROR("AuthService::login - Could not fetch user details for User ID: " + userIdToLogin + " despite valid credentials.");
        return OperationResult<std::shared_ptr<User>>::failure("Login failed due to internal error retrieving user data.", ErrorCode::OPERATION_FAILED);
    }
    
    _sessionContext.setCurrentUser(userDetails);
    LOG_INFO("AuthService::login - User " + userIdToLogin + " logged in successfully.");
    return OperationResult<std::shared_ptr<User>>::success(userDetails);
}

void AuthService::logout() {
    if (_sessionContext.isAuthenticated()) {
        LOG_INFO("AuthService::logout - User " + _sessionContext.getCurrentUserId().value_or("Unknown") + " logged out.");
        _sessionContext.clearCurrentUser();
    }
}

bool AuthService::isAuthenticated() const {
    return _sessionContext.isAuthenticated();
}
std::optional<std::string> AuthService::getCurrentUserId() const {
    return _sessionContext.getCurrentUserId();
}
std::optional<UserRole> AuthService::getCurrentUserRole() const {
    return _sessionContext.getCurrentUserRole();
}
std::optional<std::shared_ptr<User>> AuthService::getCurrentUser() const{
    return _sessionContext.getCurrentUser();
}


OperationResult<bool> AuthService::registerStudent(const StudentRegistrationData& data, const std::string& plainPassword) {
    // Validate StudentRegistrationData
    if (data.email.empty() || data.firstName.empty() || data.lastName.empty() || data.facultyId.empty() || data.citizenId.empty()) {
        return OperationResult<bool>::failure("Required registration fields are missing.", ErrorCode::VALIDATION_ERROR);
    }
    // Validate định dạng email (đơn giản)
    if (data.email.find('@') == std::string::npos || data.email.find('.') == std::string::npos) {
        return OperationResult<bool>::failure("Invalid email format.", ErrorCode::VALIDATION_ERROR);
    }
    // Validate ngày sinh
    Birthday bday(data.birthDay, data.birthMonth, data.birthYear);
    if (!bday.isSet() || !bday.validate().isValid) {
        return OperationResult<bool>::failure("Invalid birthday.", ErrorCode::VALIDATION_ERROR);
    }
    // Validate password
    ValidationResult passVr = _passwordValidator.validate(plainPassword);
    if (!passVr.isValid) {
        return OperationResult<bool>::failure("Password does not meet complexity requirements: " + passVr.getErrorMessagesCombined(), ErrorCode::VALIDATION_ERROR);
    }

    // Kiểm tra Faculty ID tồn tại
    auto facultyExists = _facultyDao->exists(data.facultyId);
    if (!facultyExists.has_value()) {
        return OperationResult<bool>::failure("Database error checking faculty: " + facultyExists.error().message, ErrorCode::DATA_ACCESS_ERROR);
    }
    if (!facultyExists.value()) {
        return OperationResult<bool>::failure("Faculty ID " + data.facultyId + " does not exist.", ErrorCode::NOT_FOUND);
    }

    // Kiểm tra email đã tồn tại chưa
    auto studentByEmail = _studentDao->findByEmail(data.email);
    if (studentByEmail.has_value()) {
        return OperationResult<bool>::failure("Email " + data.email + " already registered.", ErrorCode::ALREADY_EXISTS);
    }
    // Nếu lỗi không phải là NOT_FOUND, thì là lỗi DB
    if (studentByEmail.error().code != ErrorCode::NOT_FOUND) {
         return OperationResult<bool>::failure("Database error checking email: " + studentByEmail.error().message, ErrorCode::DATA_ACCESS_ERROR);
    }
    // Kiểm tra Citizen ID đã tồn tại chưa
    // (Cần thêm phương thức findByCitizenId vào IStudentDao và MockStudentDao/SqlStudentDao)
    // Tạm bỏ qua check này để không phải sửa nhiều file interface

    // Tạo Student ID mới (logic này nên được cải thiện, ví dụ: S + sequence number)
    // Tạm thời: dùng email làm cơ sở cho ID (không tốt cho production)
    std::string studentId = "S" + data.citizenId.substr(data.citizenId.length() > 3 ? data.citizenId.length() - 3 : 0); // Lấy 3 số cuối CCCD
    // Kiểm tra Student ID đã tồn tại chưa (phòng trường hợp logic tạo ID bị trùng)
    auto studentById = _studentDao->exists(studentId);
    if(!studentById.has_value()){
        return OperationResult<bool>::failure("Database error checking student ID: " + studentById.error().message, ErrorCode::DATA_ACCESS_ERROR);
    }
    if (studentById.value()) {
        // ID đã tồn tại, cần logic tạo ID khác hoặc báo lỗi.
        // Đây là trường hợp hiếm nếu CitizenID là unique.
        return OperationResult<bool>::failure("Generated Student ID " + studentId + " already exists. Please try again or contact admin.", ErrorCode::ALREADY_EXISTS);
    }


    Student newStudent(studentId, data.firstName, data.lastName, data.facultyId, LoginStatus::PENDING_APPROVAL);
    newStudent.setBirthday(bday);
    newStudent.setAddress(data.address);
    newStudent.setCitizenId(data.citizenId);
    newStudent.setEmail(data.email);
    newStudent.setPhoneNumber(data.phoneNumber);
    newStudent.setRole(UserRole::PENDING_STUDENT); // Role khi chờ duyệt

    // Hash password
    std::string salt = PasswordUtils::generateSalt();
    std::string hashedPassword = PasswordUtils::hashPassword(plainPassword, salt);

    // Bắt đầu transaction (nếu DAO không tự quản lý) - Giả sử DAO tự quản lý hoặc dùng chung transaction từ service cao hơn
    // Trong ví dụ này, add() của StudentDao và addUserCredentials() của LoginDao cần là atomic.
    // SQLiteAdapter đã có hỗ trợ transaction, các DAO SQL sẽ dùng nó.
    // Với Mock DAO, không có transaction thực sự.

    auto addStudentResult = _studentDao->add(newStudent);
    if (!addStudentResult.has_value()) {
        return OperationResult<bool>::failure("Failed to register student profile: " + addStudentResult.error().message, addStudentResult.error().code);
    }

    auto addCredsResult = _loginDao->addUserCredentials(studentId, hashedPassword, salt, UserRole::PENDING_STUDENT, LoginStatus::PENDING_APPROVAL);
    if (!addCredsResult.has_value() || !addCredsResult.value()) {
        // Nếu thêm student thành công nhưng thêm creds thất bại, cần rollback việc thêm student
        // Điều này nhấn mạnh sự cần thiết của transaction ở tầng Service hoặc UoW
        LOG_ERROR("AuthService::registerStudent - Added student but failed to add credentials for " + studentId + ". Attempting to remove student.");
        _studentDao->remove(studentId); // Cố gắng rollback
        return OperationResult<bool>::failure("Failed to set up login credentials: " + (addCredsResult.has_value() ? "Operation returned false" : addCredsResult.error().message),
                                            addCredsResult.has_value() ? ErrorCode::OPERATION_FAILED : addCredsResult.error().code);
    }

    LOG_INFO("AuthService::registerStudent - Student " + studentId + " registered successfully. Status: PENDING_APPROVAL.");
    return OperationResult<bool>::success(true);
}

OperationResult<bool> AuthService::changePassword(const std::string& currentUserId, const std::string& oldPassword, const std::string& newPassword) {
    if (currentUserId.empty()) {
        return OperationResult<bool>::failure("User not logged in or user ID not provided.", ErrorCode::AUTHENTICATION_FAILED);
    }

    // Validate new password complexity
    ValidationResult passVr = _passwordValidator.validate(newPassword);
    if (!passVr.isValid) {
        return OperationResult<bool>::failure("New password does not meet complexity requirements: " + passVr.getErrorMessagesCombined(), ErrorCode::VALIDATION_ERROR);
    }

    auto credsResult = _loginDao->findCredentialsByUserId(currentUserId);
    if (!credsResult.has_value()) {
        return OperationResult<bool>::failure("User not found or error fetching credentials.", credsResult.error().code == ErrorCode::NOT_FOUND ? ErrorCode::AUTHENTICATION_FAILED : credsResult.error().code);
    }
    const LoginCredentials& creds = credsResult.value();

    // Verify old password
    if (!PasswordUtils::verifyPassword(oldPassword, creds.passwordHash, creds.salt)) {
        return OperationResult<bool>::failure("Incorrect old password.", ErrorCode::AUTHENTICATION_FAILED);
    }

    // Hash new password
    std::string newSalt = PasswordUtils::generateSalt();
    std::string newHashedPassword = PasswordUtils::hashPassword(newPassword, newSalt);

    auto updateResult = _loginDao->updatePassword(currentUserId, newHashedPassword, newSalt);
    if (!updateResult.has_value() || !updateResult.value()) {
        return OperationResult<bool>::failure("Failed to update password in database: " + (updateResult.has_value() ? "Operation returned false" : updateResult.error().message),
                                            updateResult.has_value() ? ErrorCode::OPERATION_FAILED : updateResult.error().code);
    }

    LOG_INFO("AuthService::changePassword - Password changed successfully for user " + currentUserId);
    return OperationResult<bool>::success(true);
}
```
--- END OF FILE AuthService.cpp ---

--- START OF FILE InputPrompter.cpp ---
```cpp
#include "InputPrompter.h"
#include "../../utils/PasswordInput.h" // For getMaskedPassword
#include "../../utils/StringUtils.h"   // For trim
#include "../../utils/Logger.h"        // For logging invalid input attempts

std::string InputPrompter::promptForString(const std::string& promptMessage, bool allowEmpty) const {
    std::string input;
    while (true) {
        std::cout << promptMessage << " ";
        std::getline(std::cin, input);
        std::string trimmedInput = StringUtils::trim(input);
        if (!trimmedInput.empty() || allowEmpty) {
            return trimmedInput; // Trả về chuỗi đã trim nếu không rỗng, hoặc input gốc nếu allowEmpty
        }
        std::cout << "Input cannot be empty. Please try again." << std::endl;
        LOG_DEBUG("InputPrompter: Empty input received for non-empty prompt: " + promptMessage);
    }
}

long InputPrompter::promptForLong(const std::string& promptMessage, long minVal, long maxVal) const {
    long value;
    std::string line;
    while (true) {
        std::cout << promptMessage << " ";
        std::getline(std::cin, line);
        std::stringstream ss(line);
        if (ss >> value && ss.eof()) { // Kiểm tra toàn bộ chuỗi đã được parse và là số
            if (value >= minVal && value <= maxVal) {
                return value;
            } else {
                std::cout << "Value out of range. Must be between " << minVal << " and " << maxVal << ". Please try again." << std::endl;
                LOG_DEBUG("InputPrompter: Long input out of range for prompt: " + promptMessage + ". Value: " + std::to_string(value));
            }
        } else {
            std::cout << "Invalid input. Please enter a valid whole number." << std::endl;
            LOG_DEBUG("InputPrompter: Invalid long input for prompt: " + promptMessage + ". Input: " + line);
            // Xóa trạng thái lỗi của std::cin nếu có
            if (std::cin.fail()) {
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        }
    }
}

int InputPrompter::promptForInt(const std::string& promptMessage, int minVal, int maxVal) const {
    long longValue = promptForLong(promptMessage, static_cast<long>(minVal), static_cast<long>(maxVal));
    return static_cast<int>(longValue);
}

double InputPrompter::promptForDouble(const std::string& promptMessage, double minVal, double maxVal) const {
    double value;
    std::string line;
    while (true) {
        std::cout << promptMessage << " ";
        std::getline(std::cin, line);
        std::stringstream ss(line);
        if (ss >> value && ss.eof()) {
            if (value >= minVal && value <= maxVal) {
                return value;
            } else {
                std::cout << "Value out of range. Must be between " << minVal << " and " << maxVal << ". Please try again." << std::endl;
                 LOG_DEBUG("InputPrompter: Double input out of range for prompt: " + promptMessage + ". Value: " + std::to_string(value));
            }
        } else {
            std::cout << "Invalid input. Please enter a valid number." << std::endl;
            LOG_DEBUG("InputPrompter: Invalid double input for prompt: " + promptMessage + ". Input: " + line);
             if (std::cin.fail()) {
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        }
    }
}

bool InputPrompter::promptForYesNo(const std::string& promptMessage, char yesChar, char noChar) const {
    std::string input;
    char choice;
    yesChar = static_cast<char>(tolower(yesChar));
    noChar = static_cast<char>(tolower(noChar));

    while (true) {
        std::cout << promptMessage << " (" << yesChar << "/" << noChar << "): ";
        std::getline(std::cin, input);
        if (!input.empty()) {
            choice = static_cast<char>(tolower(StringUtils::trim(input)[0]));
            if (choice == yesChar) {
                return true;
            } else if (choice == noChar) {
                return false;
            }
        }
        std::cout << "Invalid choice. Please enter '" << yesChar << "' or '" << noChar << "'." << std::endl;
        LOG_DEBUG("InputPrompter: Invalid Y/N input for prompt: " + promptMessage + ". Input: " + input);
    }
}

std::string InputPrompter::promptForPassword(const std::string& promptMessage) const {
    // Sử dụng tiện ích đã có
    return PasswordUtils::getMaskedPassword(promptMessage);
}

std::string InputPrompter::promptForEmail(const std::string& promptMessage) const {
    // Ở đây có thể tích hợp GeneralInputValidator nếu đã có.
    // Tạm thời, chỉ prompt và có thể validate đơn giản.
    std::string email;
    const std::regex emailRegex(R"((\w+([-+.]\w+)*)@(\w+([-.]\w+)*\.\w+([-.]\w+)*))"); // Regex khá chuẩn
    while (true) {
        email = promptForString(promptMessage, false); // Email không được rỗng
        if (std::regex_match(email, emailRegex)) {
            return email;
        }
        std::cout << "Invalid email format. Please try again (e.g., user@example.com)." << std::endl;
        LOG_DEBUG("InputPrompter: Invalid email format for prompt: " + promptMessage + ". Input: " + email);
    }
}
```
--- END OF FILE InputPrompter.cpp ---

--- START OF FILE TableDisplayer.cpp ---
```cpp
#include "TableDisplayer.h"
#include <iostream>
#include <algorithm> // For std::max_element, std::accumulate (nếu cần tính max width tự động)

void TableDisplayer::displayTable(const std::vector<std::string>& headers,
                                  const std::vector<std::vector<std::string>>& rows,
                                  const std::vector<int>& manualColumnWidths) const {
    if (headers.empty() && rows.empty()) {
        std::cout << "(No data to display)" << std::endl;
        return;
    }
    if (!headers.empty() && !rows.empty() && headers.size() != rows[0].size()) {
        std::cerr << "TableDisplayer Error: Header count does not match column count in rows." << std::endl;
        LOG_ERROR("TableDisplayer: Header count mismatch with row column count.");
        return;
    }

    size_t numColumns = headers.empty() ? (rows.empty() ? 0 : rows[0].size()) : headers.size();
    if (numColumns == 0) {
         std::cout << "(No columns to display)" << std::endl;
        return;
    }

    std::vector<int> columnWidths = manualColumnWidths;
    if (columnWidths.empty() || columnWidths.size() != numColumns) {
        columnWidths.assign(numColumns, 0); // Reset nếu manual widths không hợp lệ

        // Tính toán độ rộng cột tự động
        if (!headers.empty()) {
            for (size_t i = 0; i < numColumns; ++i) {
                columnWidths[i] = std::max(columnWidths[i], static_cast<int>(headers[i].length()));
            }
        }
        for (const auto& row : rows) {
            for (size_t i = 0; i < numColumns; ++i) {
                 if (i < row.size()) { // Đảm bảo không truy cập ngoài biên nếu row ngắn hơn headers
                    columnWidths[i] = std::max(columnWidths[i], static_cast<int>(row[i].length()));
                }
            }
        }
        // Thêm padding
        for (size_t i = 0; i < numColumns; ++i) {
            columnWidths[i] += 2; // 1 space padding mỗi bên
            if (columnWidths[i] < 5) columnWidths[i] = 5; // Độ rộng tối thiểu
        }
    }


    // Hàm vẽ đường kẻ ngang
    auto printHorizontalLine = [&](char corner, char hChar, char join) {
        std::cout << corner;
        for (size_t i = 0; i < numColumns; ++i) {
            std::cout << std::string(columnWidths[i], hChar);
            if (i < numColumns - 1) {
                std::cout << join;
            }
        }
        std::cout << corner << std::endl;
    };
    
    // Hàm in dòng dữ liệu
    auto printRow = [&](const std::vector<std::string>& rowData, char vChar) {
        std::cout << vChar;
        for (size_t i = 0; i < numColumns; ++i) {
            std::string cellData = (i < rowData.size()) ? rowData[i] : "";
            // Căn giữa đơn giản, có thể cải thiện
            int paddingTotal = columnWidths[i] - static_cast<int>(cellData.length());
            int paddingLeft = paddingTotal / 2;
            int paddingRight = paddingTotal - paddingLeft;
            std::cout << std::string(paddingLeft, ' ') << cellData << std::string(paddingRight, ' ');
            if (i < numColumns - 1) {
                std::cout << vChar;
            }
        }
        std::cout << vChar << std::endl;
    };


    // In bảng
    printHorizontalLine('+', '-', '+'); // Đường kẻ trên cùng (thay vì '=', dùng '-' cho gọn)
    if (!headers.empty()) {
        printRow(headers, '|');
        printHorizontalLine('+', '-', '+'); // Đường kẻ dưới header
    }

    for (const auto& row : rows) {
        printRow(row, '|');
    }
    printHorizontalLine('+', '-', '+'); // Đường kẻ dưới cùng
}

// (Optional) Template method implementation (ví dụ)
// template<typename TEntity>
// void TableDisplayer::displayEntities(const std::vector<std::string>& headers,
//                                      const std::vector<TEntity>& entities,
//                                      std::function<std::vector<std::string>(const TEntity&)> rowMapper) const {
//     std::vector<std::vector<std::string>> rows;
//     for (const auto& entity : entities) {
//         rows.push_back(rowMapper(entity));
//     }
//     displayTable(headers, rows);
// }
```
--- END OF FILE TableDisplayer.cpp ---

--- START OF FILE MenuRenderer.cpp ---
```cpp
#include "MenuRenderer.h"
#include "../../utils/ConsoleUtils.h" // Cho drawHeader nếu cần

void MenuRenderer::renderMenu(const std::string& title, const std::vector<MenuItemDisplay>& items) const {
    // clearScreen(); // Có thể xóa màn hình trước khi render menu mới
    // drawHeader(title, '='); // Dùng lại hàm tiện ích nếu có
    std::cout << "\n--- " << title << " ---" << std::endl;
    for (const auto& item : items) {
        std::cout << item.key << ". " << item.description << std::endl;
    }
    std::cout << "--------------------" << std::endl;
}
```
--- END OF FILE MenuRenderer.cpp ---

--- START OF FILE ConsoleUtils.cpp ---
```cpp
#include "ConsoleUtils.h"
#include <iostream>
#include <limits> // For std::numeric_limits
#include <cstdlib> // For system()
#include <sstream> // For stringstream in promptForLong
#include "../utils/StringUtils.h" // For trim

void clearScreen() {
#ifdef _WIN32
    system("cls");
#else
    // POSIX (Linux, macOS)
    system("clear");
#endif
}

void pauseExecution(const std::string& message) {
    std::cout << message << std::flush;
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    // Một số hệ thống có thể cần 2 lần ignore nếu trước đó có cin >>
    // Nếu không, chỉ cần một lần:
    // std::string dummy;
    // std::getline(std::cin, dummy);
}

void drawHeader(const std::string& title, char borderChar) {
    std::string borderLine(title.length() + 4, borderChar); // +4 for "  " and "  "
    std::cout << borderLine << std::endl;
    std::cout << borderChar << " " << title << " " << borderChar << std::endl;
    std::cout << borderLine << std::endl;
}

void drawBox(const std::vector<std::string>& content, char borderChar) {
    if (content.empty()) return;

    size_t maxWidth = 0;
    for (const auto& line : content) {
        if (line.length() > maxWidth) {
            maxWidth = line.length();
        }
    }
    maxWidth += 2; // Padding

    std::string borderLine(maxWidth + 2, borderChar); // +2 for corners

    std::cout << borderLine << std::endl;
    for (const auto& line : content) {
        std::cout << borderChar << " " << line;
        std::cout << std::string(maxWidth - 1 - line.length(), ' '); // Fill remaining space
        std::cout << borderChar << std::endl;
    }
    std::cout << borderLine << std::endl;
}


int getMenuChoice(int minOption, int maxOption, const std::string& prompt) {
    int choice;
    std::string line;
    while (true) {
        std::cout << prompt;
        std::getline(std::cin, line);
        std::stringstream ss(line);
        if (ss >> choice && ss.eof()) { // Check if entire string was valid int
            if (choice >= minOption && choice <= maxOption) {
                return choice;
            } else {
                std::cout << "Invalid choice. Please enter a number between "
                          << minOption << " and " << maxOption << "." << std::endl;
            }
        } else {
            std::cout << "Invalid input. Please enter a number." << std::endl;
            if (std::cin.fail()){ // Should not happen with getline + stringstream for int
                 std::cin.clear();
                 std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            }
        }
    }
}

std::string promptForString(const std::string& prompt, bool allowEmpty) {
    std::string input;
    while (true) {
        std::cout << prompt;
        std::getline(std::cin, input);
        std::string trimmedInput = StringUtils::trim(input);
        if (!trimmedInput.empty() || allowEmpty) {
            return allowEmpty ? input : trimmedInput; // Trả về input gốc nếu cho phép rỗng, ngược lại trả về đã trim
        }
        std::cout << "Input cannot be empty. Please try again." << std::endl;
    }
}

long promptForLong(const std::string& prompt) {
    long value;
    std::string line;
    while (true) {
        std::cout << prompt;
        std::getline(std::cin, line);
        std::stringstream ss(line);
        if (ss >> value && ss.eof()) {
            return value;
        }
        std::cout << "Invalid input. Please enter a valid whole number." << std::endl;
        if (std::cin.fail()){
             std::cin.clear();
             std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
    }
}

bool promptForYesNo(const std::string& prompt) {
    std::string input;
    char choice;
    while (true) {
        std::cout << prompt << " (y/n): ";
        std::getline(std::cin, input);
        if (!input.empty()) {
            choice = static_cast<char>(tolower(StringUtils::trim(input)[0]));
            if (choice == 'y') {
                return true;
            } else if (choice == 'n') {
                return false;
            }
        }
        std::cout << "Invalid choice. Please enter 'y' or 'n'." << std::endl;
    }
}

```
--- END OF FILE ConsoleUtils.cpp ---

--- START OF FILE StringUtils.cpp ---
```cpp
#include "StringUtils.h"
#include <sstream> // For join

// Trim from start (in place)
static inline void ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
}

// Trim from end (in place)
static inline void rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), s.end());
}

// Trim from both ends (in place)
static inline void trim_inplace(std::string &s) {
    ltrim(s);
    rtrim(s);
}

// Trim from both ends (copy)
std::string StringUtils::trim(const std::string& str) {
    std::string s = str;
    trim_inplace(s);
    return s;
}

std::string StringUtils::toLower(const std::string& str) {
    std::string lowerStr = str;
    std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(),
                   [](unsigned char c){ return std::tolower(c); });
    return lowerStr;
}

std::string StringUtils::toUpper(const std::string& str) {
    std::string upperStr = str;
    std::transform(upperStr.begin(), upperStr.end(), upperStr.begin(),
                   [](unsigned char c){ return std::toupper(c); });
    return upperStr;
}

std::vector<std::string> StringUtils::split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(str);
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

std::string StringUtils::join(const std::vector<std::string>& elements, char delimiter) {
    std::ostringstream oss;
    for (size_t i = 0; i < elements.size(); ++i) {
        oss << elements[i];
        if (i < elements.size() - 1) {
            oss << delimiter;
        }
    }
    return oss.str();
}

bool StringUtils::startsWith(const std::string& str, const std::string& prefix) {
    return str.rfind(prefix, 0) == 0; // pos=0 ensures prefix is at the start
}

bool StringUtils::endsWith(const std::string& str, const std::string& suffix) {
    if (suffix.length() > str.length()) return false;
    return str.compare(str.length() - suffix.length(), suffix.length(), suffix) == 0;
}

bool StringUtils::contains(const std::string& str, const std::string& substring) {
    return str.find(substring) != std::string::npos;
}

```
--- END OF FILE StringUtils.cpp ---

--- START OF FILE OperationResult.h ---
```cpp
#ifndef OPERATIONRESULT_H
#define OPERATIONRESULT_H

#include <optional>
#include <string>
#include <utility> // For std::move
#include "ErrorType.h" // Để dùng Error struct

template <typename T>
class OperationResult {
private:
    std::optional<T> _value;
    std::optional<Error> _error; // (➕) Sử dụng Error struct
    bool _isSuccess;

    // Constructor riêng tư, dùng các factory method bên dưới
    OperationResult(T val) : _value(std::move(val)), _isSuccess(true) {}
    OperationResult(Error err) : _error(std::move(err)), _isSuccess(false) {}
    OperationResult(bool success) : _isSuccess(success) {} // Cho trường hợp T = void (bool)

public:
    bool isSuccess() const { return _isSuccess; }
    bool hasValue() const { return _value.has_value(); }
    
    const T& getValue() const {
        // Nên kiểm tra isSuccess() hoặc hasValue() trước khi gọi
        // Hoặc có thể throw nếu !hasValue()
        if (!_value) throw std::logic_error("Attempted to get value from a failed or empty OperationResult");
        return _value.value();
    }

    T& getValue() { // (➕) Non-const version
        if (!_value) throw std::logic_error("Attempted to get value from a failed or empty OperationResult");
        return _value.value();
    }

    const Error& getError() const {
        if (!_error) throw std::logic_error("Attempted to get error from a successful or valueless OperationResult");
        return _error.value();
    }
     Error& getError() { // (➕) Non-const version
        if (!_error) throw std::logic_error("Attempted to get error from a successful or valueless OperationResult");
        return _error.value();
    }

    std::string getErrorMessage() const {
        if (_error) return _error.value().message;
        return _isSuccess ? "Operation successful." : "Operation failed without specific error message.";
    }
    int getErrorCode() const {
        if(_error) return _error.value().code;
        return _isSuccess ? 0 : -1; // Mã mặc định
    }


    // Factory methods
    static OperationResult<T> success(T value) {
        return OperationResult<T>(std::move(value));
    }
    // Cho T = void, tức là OperationResult<bool>
    static OperationResult<T> success() {
        static_assert(std::is_same_v<T, bool>, "Success without value is only for OperationResult<bool>");
        return OperationResult<T>(true);
    }

    static OperationResult<T> failure(const std::string& errorMessage, int errorCode = ErrorCode::OPERATION_FAILED) {
        return OperationResult<T>(Error(errorCode, errorMessage));
    }
    static OperationResult<T> failure(const Error& error) {
        return OperationResult<T>(error);
    }
};

// Chuyên biệt hóa cho T = void (thường được đại diện bằng OperationResult<bool>)
template <>
class OperationResult<void> {
private:
    std::optional<Error> _error;
    bool _isSuccess;

    OperationResult(bool success) : _isSuccess(success) {}
    OperationResult(Error err) : _error(std::move(err)), _isSuccess(false) {}

public:
    bool isSuccess() const { return _isSuccess; }
    
    const Error& getError() const {
        if (!_error) throw std::logic_error("Attempted to get error from a successful OperationResult<void>");
        return _error.value();
    }
    Error& getError() {
         if (!_error) throw std::logic_error("Attempted to get error from a successful OperationResult<void>");
        return _error.value();
    }

    std::string getErrorMessage() const {
        if (_error) return _error.value().message;
        return _isSuccess ? "Operation successful." : "Operation failed without specific error message.";
    }
     int getErrorCode() const {
        if(_error) return _error.value().code;
        return _isSuccess ? 0 : -1;
    }

    static OperationResult<void> success() {
        return OperationResult<void>(true);
    }
    static OperationResult<void> failure(const std::string& errorMessage, int errorCode = ErrorCode::OPERATION_FAILED) {
        return OperationResult<void>(Error(errorCode, errorMessage));
    }
     static OperationResult<void> failure(const Error& error) {
        return OperationResult<void>(error);
    }
};

// Nếu bạn vẫn muốn dùng OperationResult<bool> thay vì OperationResult<void>
// thì không cần chuyên biệt hóa OperationResult<void>, mà dùng OperationResult<T>
// và gọi OperationResult<bool>::success(true) và OperationResult<bool>::success(false)
// hoặc OperationResult<bool>::failure(...)

#endif // OPERATIONRESULT_H
```
--- END OF FILE OperationResult.h ---

--- START OF FILE SessionContext.cpp ---
```cpp
#include "SessionContext.h"

void SessionContext::setCurrentUser(std::shared_ptr<User> user) {
    _currentUser = std::move(user);
}

void SessionContext::clearCurrentUser() {
    _currentUser.reset();
}

bool SessionContext::isAuthenticated() const {
    return _currentUser.has_value();
}

std::optional<std::string> SessionContext::getCurrentUserId() const {
    if (_currentUser) {
        return (*_currentUser)->getId();
    }
    return std::nullopt;
}

std::optional<UserRole> SessionContext::getCurrentUserRole() const {
    if (_currentUser) {
        return (*_currentUser)->getRole();
    }
    return std::nullopt;
}

std::optional<std::shared_ptr<User>> SessionContext::getCurrentUser() const {
    return _currentUser;
}
```
--- END OF FILE SessionContext.cpp ---

--- START OF FILE StudentValidator.h ---
```cpp
#ifndef STUDENTVALIDATOR_H
#define STUDENTVALIDATOR_H

#include "../interface/IValidator.h"
#include "../../entities/Student.h"
#include "../../data_access/interface/IFacultyDao.h" // Để kiểm tra facultyId tồn tại
#include "../../data_access/interface/IStudentDao.h" // Để kiểm tra email, citizenId unique
#include <memory>

class StudentValidator : public IEntityValidator<Student> {
private:
    std::shared_ptr<IFacultyDao> _facultyDao;
    std::shared_ptr<IStudentDao> _studentDao; // Để check unique

public:
    StudentValidator(std::shared_ptr<IFacultyDao> facultyDao, std::shared_ptr<IStudentDao> studentDao);
    ValidationResult validateEntity(const Student& student) const override;
    // (➕) Thêm hàm validate cho StudentRegistrationData nếu cần
    ValidationResult validateRegistrationData(const StudentRegistrationData& regData, const std::string& studentIdForUniquenessCheck = "") const;

};

#endif // STUDENTVALIDATOR_H
```
--- END OF FILE StudentValidator.h ---

--- START OF FILE StudentValidator.cpp ---
```cpp
#include "StudentValidator.h"
#include "../../../utils/StringUtils.h"
#include "../../entities/User.h" // for StudentRegistrationData

StudentValidator::StudentValidator(std::shared_ptr<IFacultyDao> facultyDao, std::shared_ptr<IStudentDao> studentDao)
    : _facultyDao(std::move(facultyDao)), _studentDao(std::move(studentDao)) {
    if (!_facultyDao) throw std::runtime_error("StudentValidator: IFacultyDao cannot be null.");
    if (!_studentDao) throw std::runtime_error("StudentValidator: IStudentDao cannot be null.");
}

ValidationResult StudentValidator::validateEntity(const Student& student) const {
    ValidationResult vr = student.validateBasic(); // Validate các rule cơ bản từ entity
    if (!vr.isValid) {
        return vr; // Trả về ngay nếu validation cơ bản thất bại
    }

    // Validate sự tồn tại của FacultyId
    auto facultyExists = _facultyDao->exists(student.getFacultyId());
    if (!facultyExists.has_value()) {
        vr.addError(ErrorCode::DATA_ACCESS_ERROR, "Could not verify faculty: " + facultyExists.error().message);
        return vr;
    }
    if (!facultyExists.value()) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Faculty with ID " + student.getFacultyId() + " does not exist.");
    }

    // Validate email unique (nếu không phải là update chính student đó)
    auto studentByEmail = _studentDao->findByEmail(student.getEmail());
    if (studentByEmail.has_value()) {
        if (studentByEmail.value().getId() != student.getId()) { // Email thuộc về student khác
            vr.addError(ErrorCode::ALREADY_EXISTS, "Email " + student.getEmail() + " is already in use by another student.");
        }
    } else if (studentByEmail.error().code != ErrorCode::NOT_FOUND) {
        vr.addError(ErrorCode::DATA_ACCESS_ERROR, "Could not verify email uniqueness: " + studentByEmail.error().message);
    }

    // Validate citizenId unique (nếu không phải là update chính student đó)
    // Cần thêm IStudentDao::findByCitizenId(const std::string& citizenId)
    // Tạm thời bỏ qua, vì interface chưa có hàm này.
    /*
    auto studentByCitizenId = _studentDao->findByCitizenId(student.getCitizenId());
    if (studentByCitizenId.has_value()) {
        if (studentByCitizenId.value().getId() != student.getId()) {
            vr.addError(ErrorCode::ALREADY_EXISTS, "Citizen ID " + student.getCitizenId() + " is already registered.");
        }
    } else if (studentByCitizenId.error().code != ErrorCode::NOT_FOUND) {
        vr.addError(ErrorCode::DATA_ACCESS_ERROR, "Could not verify citizen ID uniqueness: " + studentByCitizenId.error().message);
    }
    */

    return vr;
}

ValidationResult StudentValidator::validateRegistrationData(const StudentRegistrationData& regData, const std::string& studentIdToExclude) const {
    ValidationResult vr;

    if (StringUtils::trim(regData.firstName).empty()) vr.addError(ErrorCode::VALIDATION_ERROR, "First name cannot be empty.");
    if (StringUtils::trim(regData.lastName).empty()) vr.addError(ErrorCode::VALIDATION_ERROR, "Last name cannot be empty.");
    
    if (StringUtils::trim(regData.email).empty()) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Email cannot be empty.");
    } else {
        // Basic email format (can be improved with regex)
        if (regData.email.find('@') == std::string::npos || regData.email.find('.') == std::string::npos) {
            vr.addError(ErrorCode::VALIDATION_ERROR, "Invalid email format.");
        } else {
            // Check email uniqueness
            auto studentByEmail = _studentDao->findByEmail(regData.email);
            if (studentByEmail.has_value()) {
                if (studentIdToExclude.empty() || studentByEmail.value().getId() != studentIdToExclude) {
                     vr.addError(ErrorCode::ALREADY_EXISTS, "Email " + regData.email + " is already in use.");
                }
            } else if (studentByEmail.error().code != ErrorCode::NOT_FOUND) {
                 vr.addError(ErrorCode::DATA_ACCESS_ERROR, "Could not verify email uniqueness: " + studentByEmail.error().message);
            }
        }
    }

    if (StringUtils::trim(regData.citizenId).empty()) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Citizen ID cannot be empty.");
    } else {
        // Basic citizen ID format (e.g., 9 or 12 digits)
        std::string cid = StringUtils::trim(regData.citizenId);
        bool allDigits = std::all_of(cid.begin(), cid.end(), ::isdigit);
        if (!allDigits || (cid.length() != 9 && cid.length() != 12)) {
            vr.addError(ErrorCode::VALIDATION_ERROR, "Citizen ID must be 9 or 12 digits.");
        } else {
            // Check Citizen ID uniqueness (requires findByCitizenId in IStudentDao)
            // Tạm bỏ qua
        }
    }

    Birthday bday(regData.birthDay, regData.birthMonth, regData.birthYear);
    if (!bday.isSet()) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Birthday is not set or invalid.");
    } else {
        ValidationResult bdayVr = bday.validate();
        if (!bdayVr.isValid) {
            for (const auto& err : bdayVr.errors) vr.addError(err);
        }
    }

    if (StringUtils::trim(regData.facultyId).empty()) {
        vr.addError(ErrorCode::VALIDATION_ERROR, "Faculty ID cannot be empty.");
    } else {
        auto facultyExists = _facultyDao->exists(regData.facultyId);
        if (!facultyExists.has_value()) {
            vr.addError(ErrorCode::DATA_ACCESS_ERROR, "Could not verify faculty: " + facultyExists.error().message);
        } else if (!facultyExists.value()) {
            vr.addError(ErrorCode::NOT_FOUND, "Faculty with ID " + regData.facultyId + " does not exist.");
        }
    }
    
    // Phone number (optional, but validate if provided)
    if (!StringUtils::trim(regData.phoneNumber).empty()) {
        std::string phone = StringUtils::trim(regData.phoneNumber);
        bool allDigits = std::all_of(phone.begin(), phone.end(), ::isdigit);
        if (!allDigits || (phone.length() < 10 || phone.length() > 11)) { // Simple check
            vr.addError(ErrorCode::VALIDATION_ERROR, "Invalid phone number format (must be 10-11 digits).");
        }
    }

    return vr;
}
```
--- END OF FILE StudentValidator.cpp ---

Phần tiếp theo sẽ tập trung vào `ConsoleUI` và `main.cpp` nếu còn đủ chỗ.
Tôi đã triển khai các phần SQL DAO và Parser cho Student làm ví dụ, cập nhật DaoFactory, triển khai PasswordValidator và StudentValidator, UI Helpers, và AuthService (sử dụng mock DAO). Cấu trúc cho các SQL DAO khác sẽ tương tự như SqlStudentDao.

Do giới hạn, tôi không thể triển khai toàn bộ các SQL DAO còn lại, các Service khác, hoặc hoàn chỉnh ConsoleUI và Unit Test trong một phản hồi. Tuy nhiên, đây là nền tảng vững chắc để bạn tiếp tục.

Các bước tiếp theo bạn có thể làm:
1.  Hoàn thiện các **SQL DAO** còn lại (`SqlTeacherDao`, `SqlFacultyDao`, v.v.) và các **SQL Parser** tương ứng.
2.  Triển khai các **Service** còn lại, inject các DAO đã tạo (SQL hoặc Mock tùy theo `AppConfig`).
3.  Mở rộng **ConsoleUI** để có thêm các menu và chức năng tương tác với các Service.
4.  Viết **Unit Tests** cho các Service và Validators.
5.  Hoàn thiện `main.cpp` để khởi tạo `AppConfig`, `DaoFactory`, các `Service`, `SessionContext`, và `ConsoleUI`, sau đó chạy UI.

Ví dụ cho `main.cpp` (rất cơ bản):
```cpp
// src/main.cpp
#include <iostream>
#include <memory>
#include "common/AppConfig.h"
#include "core/data_access/DaoFactory.h"
#include "core/services/impl/AuthService.h"
// ... include các service khác
#include "ui/ConsoleUI.h"
#include "utils/Logger.h"
#include "core/session/SessionContext.h"

int main() {
    // 1. Load AppConfig (tạm thời tạo config mặc định)
    AppConfig config;
    config.dataSourceType = DataSourceType::MOCK; // Hoặc SQLITE
    // Nếu là SQLITE:
    // config.sqlConnectionString = "university.db"; // Tên file DB
    // config.logFilePath = "logs/app.log";
    // config.logLevel = Logger::Level::DEBUG;


    // 2. Configure Logger
    Logger::getInstance().configure(config.logLevel, config.logFilePath.string());
    LOG_INFO("Application starting...");

    // 3. Create SessionContext
    SessionContext sessionContext;

    // 4. Create DAOs using Factory
    auto loginDao = DaoFactory::createLoginDao(config);
    auto studentDao = DaoFactory::createStudentDao(config);
    auto teacherDao = DaoFactory::createTeacherDao(config);
    auto facultyDao = DaoFactory::createFacultyDao(config);
    // ... tạo các DAO khác

    if (!loginDao || !studentDao /* || ... các DAO khác */) {
        LOG_CRITICAL("Failed to initialize one or more DAOs. Application cannot start.");
        Logger::releaseInstance();
        return 1;
    }

    // 5. Create Services (inject DAOs và SessionContext)
    auto authService = std::make_shared<AuthService>(loginDao, studentDao, teacherDao, facultyDao, sessionContext);
    // ... tạo các service khác (studentService, teacherService, ...)
    // std::shared_ptr<IStudentService> studentService = std::make_shared<StudentService>(studentDao, facultyDao); 
    // std::shared_ptr<ITeacherService> teacherService = std::make_shared<TeacherService>(teacherDao, facultyDao);
    // ... và các service khác ...
    // Để ConsoleUI biên dịch được, cần cung cấp các shared_ptr (có thể là nullptr nếu chưa implement service đó)
    std::shared_ptr<IStudentService> studentService = nullptr; // Placeholder
    std::shared_ptr<ITeacherService> teacherService = nullptr; // Placeholder
    std::shared_ptr<IFacultyService> facultyService = nullptr; // Placeholder
    std::shared_ptr<ICourseService> courseService = nullptr;   // Placeholder
    std::shared_ptr<IEnrollmentService> enrollmentService = nullptr; // Placeholder
    std::shared_ptr<IResultService> resultService = nullptr;   // Placeholder
    std::shared_ptr<IFinanceService> financeService = nullptr; // Placeholder
    std::shared_ptr<IAdminService> adminService = nullptr;     // Placeholder


    // 6. Create and Run UI
    try {
        ConsoleUI ui(
            authService, studentService, teacherService, facultyService,
            courseService, enrollmentService, resultService, financeService, adminService
        );
        ui.run();
    } catch (const std::exception& e) {
        LOG_CRITICAL("Unhandled exception in UI: " + std::string(e.what()));
        std::cerr << "Critical error: " << e.what() << std::endl;
    }


    LOG_INFO("Application shutting down...");
    Logger::releaseInstance(); // Dọn dẹp logger
    return 0;
}
```

Và `ConsoleUI.cpp` (khung sườn cơ bản):
```cpp
// src/ui/ConsoleUI.cpp
#include "ConsoleUI.h"
#include "MenuOption.h"
#include "InputPrompter.h"   // Đã tạo file .cpp
#include "TableDisplayer.h"  // Đã tạo file .cpp
#include "MenuRenderer.h"    // Đã tạo file .cpp
#include "../utils/ConsoleUtils.h" // Đã tạo file .cpp
#include "../utils/Logger.h"
#include <iostream>
#include <limits> // For numeric_limits


ConsoleUI::ConsoleUI(
    std::shared_ptr<IAuthService> authService,
    std::shared_ptr<IStudentService> studentService,
    std::shared_ptr<ITeacherService> teacherService,
    std::shared_ptr<IFacultyService> facultyService,
    std::shared_ptr<ICourseService> courseService,
    std::shared_ptr<IEnrollmentService> enrollmentService,
    std::shared_ptr<IResultService> resultService,
    std::shared_ptr<IFinanceService> financeService,
    std::shared_ptr<IAdminService> adminService
) : _authService(authService),
    _studentService(studentService),
    _teacherService(teacherService),
    _facultyService(facultyService),
    _courseService(courseService),
    _enrollmentService(enrollmentService),
    _resultService(resultService),
    _financeService(financeService),
    _adminService(adminService),
    _inputPrompter(std::make_unique<InputPrompter>()),
    _tableDisplayer(std::make_unique<TableDisplayer>()),
    _menuRenderer(std::make_unique<MenuRenderer>())
{
    if (!_authService) LOG_CRITICAL("ConsoleUI: IAuthService is null!");
    // Kiểm tra các service khác tương tự nếu chúng là bắt buộc
}

void ConsoleUI::run() {
    MainMenuOption choice;
    do {
        displayMainMenu();
        int menuChoice = _inputPrompter->promptForInt("Enter your choice: ", 0, 3);
        choice = static_cast<MainMenuOption>(menuChoice);
        handleMainMenuChoice(choice);
    } while (choice != MainMenuOption::EXIT);
    std::cout << "Exiting University Management System. Goodbye!" << std::endl;
}

void ConsoleUI::displayMainMenu() {
    std::vector<MenuItemDisplay> items = {
        {"1", "Finance Portal"},
        {"2", "Admin Portal"},
        {"3", "Login (Student/Teacher)"},
        {"0", "Exit"}
    };
    _menuRenderer->renderMenu("Main Menu", items);
}

void ConsoleUI::handleMainMenuChoice(MainMenuOption choice) {
    clearScreen(); // Xóa màn hình cho menu mới
    switch (choice) {
        case MainMenuOption::FINANCE:
            std::cout << "Finance Portal (Not Implemented Yet)" << std::endl;
            // handleFinanceMenu();
            break;
        case MainMenuOption::ADMIN:
            handleAdminLoginAndActions();
            break;
        case MainMenuOption::LOGIN:
            handleUserLoginAndActions();
            break;
        case MainMenuOption::EXIT:
            LOG_INFO("User chose to exit.");
            break;
        default:
            std::cout << "Invalid choice. Please try again." << std::endl;
            LOG_WARN("Invalid main menu choice made by user.");
    }
    if (choice != MainMenuOption::EXIT) {
        pauseExecution();
    }
}

void ConsoleUI::handleAdminLoginAndActions() {
    if (!_authService) {
        std::cout << "Authentication service is not available." << std::endl;
        return;
    }
    if (_authService->isAuthenticated() && _authService->getCurrentUserRole().value_or(UserRole::UNKNOWN) == UserRole::ADMIN) {
        std::cout << "Admin already logged in." << std::endl;
        // displayAdminMenu();
        return;
    }

    std::cout << "--- Admin Login ---" << std::endl;
    std::string adminId = _inputPrompter->promptForString("Admin ID:", false);
    std::string password = _inputPrompter->promptForPassword("Password:");

    auto loginResult = _authService->login(adminId, password);
    if (loginResult.isSuccess() && loginResult.getValue()->getRole() == UserRole::ADMIN) {
        std::cout << "Admin login successful. Welcome, " << loginResult.getValue()->getFirstName() << "!" << std::endl;
        LOG_INFO("Admin " + adminId + " logged in.");
        // displayAdminMenu(); // Gọi menu admin
        std::cout << "Admin Menu (Not Implemented Yet)" << std::endl;
        _authService->logout(); // Tạm thời logout sau khi hiển thị
    } else {
        std::cout << "Admin login failed: " << loginResult.getErrorMessage() << std::endl;
        LOG_WARN("Admin login failed for ID: " + adminId + ". Reason: " + loginResult.getErrorMessage());
    }
}

void ConsoleUI::handleUserLoginAndActions() {
     if (!_authService) {
        std::cout << "Authentication service is not available." << std::endl;
        return;
    }
    if (_authService->isAuthenticated()) {
        std::cout << "Already logged in as " << _authService->getCurrentUserId().value_or("Unknown") << std::endl;
        // Dựa vào role để hiển thị menu tương ứng
        // if (_authService->getCurrentUserRole() == UserRole::STUDENT) displayStudentMenu();
        // else if (_authService->getCurrentUserRole() == UserRole::TEACHER) displayTeacherMenu();
        return;
    }

    std::cout << "--- User Login (Student/Teacher) ---" << std::endl;
    std::string userIdOrEmail = _inputPrompter->promptForString("User ID or Email:", false);
    std::string password = _inputPrompter->promptForPassword("Password:");

    auto loginResult = _authService->login(userIdOrEmail, password);
    if (loginResult.isSuccess()) {
        std::shared_ptr<User> user = loginResult.getValue();
        std::cout << "Login successful. Welcome, " << user->getFullName() << "!" << std::endl;
        LOG_INFO("User " + user->getId() + " logged in as " + toStringUserRole(user->getRole()));

        if (user->getRole() == UserRole::STUDENT) {
            // displayStudentMenu();
             std::cout << "Student Menu (Not Implemented Yet)" << std::endl;
        } else if (user->getRole() == UserRole::TEACHER) {
            // displayTeacherMenu();
            std::cout << "Teacher Menu (Not Implemented Yet)" << std::endl;
        } else {
            std::cout << "Logged in with an unhandled role: " << toStringUserRole(user->getRole()) << std::endl;
        }
        _authService->logout(); // Tạm thời logout
    } else {
        std::cout << "Login failed: " << loginResult.getErrorMessage() << std::endl;
        LOG_WARN("User login failed for: " + userIdOrEmail + ". Reason: " + loginResult.getErrorMessage());
        // Cân nhắc có nên hiển thị menu đăng ký nếu login thất bại không
        bool registerChoice = _inputPrompter->promptForYesNo("Login failed. Would you like to register as a new student?");
        if (registerChoice) {
            handleStudentRegistration();
        }
    }
}


StudentRegistrationData ConsoleUI::promptForStudentRegistrationData() {
    StudentRegistrationData data;
    std::cout << "\n--- New Student Registration ---" << std::endl;
    data.firstName = _inputPrompter->promptForString("First Name:", false);
    data.lastName = _inputPrompter->promptForString("Last Name:", false);
    data.email = _inputPrompter->promptForEmail("Email:");
    data.citizenId = _inputPrompter->promptForString("Citizen ID (9 or 12 digits):", false);
    data.phoneNumber = _inputPrompter->promptForString("Phone Number (10-11 digits, optional):", true);
    data.address = _inputPrompter->promptForString("Address (optional):", true);
    data.facultyId = _inputPrompter->promptForString("Faculty ID (e.g., IT, CS):", false);
    std::cout << "Enter Birthday:" << std::endl;
    data.birthDay = _inputPrompter->promptForInt("  Day (1-31):", 1, 31);
    data.birthMonth = _inputPrompter->promptForInt("  Month (1-12):", 1, 12);
    data.birthYear = _inputPrompter->promptForInt("  Year (e.g., 2000):", 1900, 2020); // Giới hạn năm hợp lý
    return data;
}

void ConsoleUI::handleStudentRegistration() {
    if (!_authService) {
        std::cout << "Authentication service is not available for registration." << std::endl;
        return;
    }
    StudentRegistrationData regData = promptForStudentRegistrationData();
    std::string password = _inputPrompter->promptForPassword("Enter password:");
    std::string confirmPassword = _inputPrompter->promptForPassword("Confirm password:");

    if (password != confirmPassword) {
        std::cout << "Passwords do not match. Registration aborted." << std::endl;
        LOG_WARN("Student registration: Passwords mismatch.");
        return;
    }

    auto result = _authService->registerStudent(regData, password);
    if (result.isSuccess() && result.getValue()) {
        std::cout << "Registration successful! Your application is pending approval by an administrator." << std::endl;
        LOG_INFO("Student registration submitted for email: " + regData.email);
    } else {
        std::cout << "Registration failed: " << result.getErrorMessage() << std::endl;
        LOG_ERROR("Student registration failed for email: " + regData.email + ". Reason: " + result.getErrorMessage());
    }
}

// ... các hàm display menu và handle action khác sẽ được thêm ở đây ...
```

Để biên dịch và chạy được, bạn cần đảm bảo các file header còn thiếu (ví dụ các SQL DAO, parser, service khác) được tạo ra (dù chỉ là khai báo rỗng hoặc kế thừa từ interface) hoặc `#include` chúng trong `ConsoleUI.h` và `main.cpp` được comment lại nếu chưa dùng. Các implementation service cũng cần được cung cấp (dù là trả về `OperationResult::failure("Not implemented")` ban đầu).